<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetScope - Professional RF Design Tool</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/konva/8.4.3/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-color: #3b82f6;
            --primary-dark: #2563eb;
            --secondary-color: #8b5cf6;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --border-color: #475569;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Topbar */
        #topbar {
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: var(--shadow);
            z-index: 100;
        }
        
        #project-name {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 14px;
            width: 250px;
        }
        
        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            box-shadow: var(--shadow);
        }
        
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
        }
        
        .btn-secondary:hover {
            background: var(--border-color);
        }
        
        .btn-success {
            background: var(--success-color);
        }
        
        .btn-warning {
            background: var(--warning-color);
        }
        
        .btn-danger {
            background: var(--danger-color);
        }
        
        /* Main Content */
        #main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Left Toolbar */
        #left-toolbar {
            width: 80px;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 16px 8px;
            gap: 8px;
            box-shadow: var(--shadow);
        }
        
        .tool-btn {
            width: 64px;
            height: 64px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s;
            color: var(--text-secondary);
            font-size: 11px;
        }
        
        .tool-btn:hover {
            background: var(--border-color);
            border-color: var(--primary-color);
            color: var(--text-primary);
        }
        
        .tool-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-dark);
            color: white;
        }
        
        .tool-btn svg {
            width: 24px;
            height: 24px;
        }
        
        /* Canvas Container */
        #canvas-container {
            flex: 1;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }
        
        #konva-container {
            width: 100%;
            height: 100%;
        }
        
        /* Right Inspector */
        #inspector {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }
        
        .inspector-section {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: var(--shadow);
        }
        
        .inspector-section h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .form-group input[type="range"] {
            padding: 0;
        }
        
        .slider-value {
            display: inline-block;
            background: var(--primary-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 8px;
        }
        
        /* Heatmap Controls */
        #heatmap-controls {
            position: absolute;
            bottom: 20px;
            left: 100px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 10;
        }
        
        #heatmap-controls label {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lg);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            font-size: 20px;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 24px;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .close-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Device Library Modal */
        #device-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .device-item {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .device-item:hover {
            border-color: var(--primary-color);
            background: var(--border-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .device-item .device-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .device-item .device-specs {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Loading Indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            z-index: 999;
            display: none;
        }
        
        .loading.active {
            display: block;
        }
        
        /* Status Bar */
        #status-bar {
            position: absolute;
            bottom: 0;
            left: 80px;
            right: 320px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 8px 16px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        /* Signal Tooltip */
        #signal-tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            z-index: 500;
            display: none;
            box-shadow: var(--shadow-lg);
            min-width: 200px;
        }
        
        #signal-tooltip.active {
            display: block;
        }
        
        .signal-item {
            font-size: 12px;
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .signal-strong { color: #10b981; }
        .signal-good { color: #84cc16; }
        .signal-fair { color: #f59e0b; }
        .signal-weak { color: #ef4444; }
        
        /* Responsive */
        @media (max-width: 768px) {
            #inspector {
                position: absolute;
                right: -320px;
                top: 0;
                bottom: 0;
                transition: right 0.3s;
                z-index: 50;
            }
            
            #inspector.mobile-open {
                right: 0;
            }
            
            #left-toolbar {
                width: 60px;
            }
            
            .tool-btn {
                width: 48px;
                height: 48px;
                font-size: 10px;
            }
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }
        
        /* Hidden file inputs */
        .hidden-input {
            display: none;
        }
    </style>
</head>
<body>
    <div id="app">
    <!-- Topbar -->
        <div id="topbar">
            <input type="text" id="project-name" value="Untitled Project" placeholder="Project Name" aria-label="Project Name">
            <button class="btn" id="new-project-btn" aria-label="New Project">
                <i data-feather="plus-circle"></i> New
            </button>
            <button class="btn btn-secondary" id="open-project-btn" aria-label="Open Project">
                <i data-feather="folder"></i> Open
            </button>
            <button class="btn btn-success" id="save-project-btn" aria-label="Save Project">
                <i data-feather="save"></i> Save
            </button>
            <button class="btn btn-warning" id="export-pdf-btn" aria-label="Export PDF">
                <i data-feather="file"></i> Export PDF
            </button>
            <button class="btn btn-warning" id="export-heatmap-btn" aria-label="Export Heatmap PNG">
                <i data-feather="image"></i> Export Heatmap
            </button>
            <button class="btn btn-secondary" id="help-btn" aria-label="Help">
                <i data-feather="help-circle"></i> Help
            </button>            
            <div style="flex: 1"></div>
            <label>
                <input type="checkbox" id="density-heatmap-toggle"> Show Client Density
            </label>
            <label style="display: flex; align-items: center; gap: 8px; color: var(--text-secondary); font-size: 14px;">
                <input type="checkbox" id="grid-toggle"> Show Grid
            </label>
            <label style="display: flex; align-items: center; gap: 8px; color: var(--text-secondary); font-size: 14px; margin-left: 12px;">
                <input type="checkbox" id="snap-toggle" checked> Snap to Grid
            </label>
        </div>
        
        <!-- Help Box -->
        <div id="help-box" style="position: absolute; top: 70px; left: 100px; background: var(--bg-secondary); border: 2px solid var(--primary-color); border-radius: 8px; padding: 20px; max-width: 400px; z-index: 200; box-shadow: var(--shadow-lg); display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h3 style="margin: 0;">Quick Start Guide</h3>
                <button class="close-btn" id="close-help">&times;</button>
            </div>
            <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                <p><strong>1. Upload Floor Plan:</strong> Click Upload button and select an image or PDF</p>
                <p><strong>2. Set Scale:</strong> Click Scale tool, click 2 points of known distance, enter real distance in feet</p>
                <p><strong>3. Add Access Points:</strong> Click "Add AP", select device, click on canvas to place</p>
                <p><strong>4. Draw Walls:</strong> Click Wall tool, click multiple points, double-click to finish</p>
                <p><strong>5. View Heatmap:</strong> Automatically updates as you add/move APs</p>
                <p style="margin-top: 12px;"><strong>Keyboard Shortcuts:</strong></p>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li><strong>V</strong> - Select tool</li>
                    <li><strong>A</strong> - Add AP</li>
                    <li><strong>W</strong> - Draw wall</li>
                    <li><strong>Ctrl+Z</strong> - Undo / Remove last wall point</li>
                    <li><strong>Backspace</strong> - Remove last wall point</li>
                    <li><strong>ESC</strong> - Cancel current action</li>
                    <li><strong>Delete</strong> - Remove selected object</li>
                    <li><strong>Space + Drag</strong> - Pan canvas</li>
                    <li><strong>Mouse Wheel</strong> - Zoom in/out</li>
                    <li><strong>Ctrl+S</strong> - Save project</li>
                </ul>
                <p style="margin-top: 12px;"><strong>Tips:</strong></p>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li>Right-click objects to delete them</li>
                    <li>Drag APs to reposition - client lines update automatically</li>
                    <li>Click on rooms in the right panel to rename them</li>
                    <li>Coverage circles show signal strength zones</li>
                    <li>Enable grid and snap for precise placement</li>
                    <li>Change wall materials to see coverage impact</li>
                </ul>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <!-- Left Toolbar -->
            <div id="left-toolbar">
                <button class="tool-btn" id="upload-floor-btn" data-tool="upload" aria-label="Upload Floor Plan">
                    <i data-feather="upload"></i>
                    <span>Upload</span>
                </button>
                <button class="tool-btn" id="scale-tool-btn" data-tool="scale" aria-label="Scale Tool">
                    <i data-feather="maximize"></i>
                    <span>Scale</span>
                </button>
                <button class="tool-btn" id="draw-wall-btn" data-tool="wall" aria-label="Draw Wall">
                    <i data-feather="minus"></i>
                    <span>Wall</span>
                </button>
                <button class="tool-btn" id="add-ap-btn" data-tool="ap" aria-label="Add Access Point">
                    <i data-feather="wifi"></i>
                    <span>Add AP</span>
                </button>
                <button class="tool-btn" id="add-client-btn" data-tool="client" aria-label="Add Client">
                    <i data-feather="smartphone"></i>
                    <span>Client</span>
                </button>
                <button class="tool-btn" id="add-obstacle-btn" data-tool="obstacle" aria-label="Add Obstacle">
                    <i data-feather="square"></i>
                    <span>Obstacle</span>
                </button>
                <button class="tool-btn active" id="select-tool-btn" data-tool="select" aria-label="Select Tool">
                    <i data-feather="move"></i>
                    <span>Select</span>
                </button>
                <button class="tool-btn" id="measure-tool-btn" data-tool="measure" aria-label="Measure Tool">
                    <i data-feather="crosshair"></i>
                    <span>Measure</span>
                </button>
                <button class="tool-btn" id="signal-tool-btn" data-tool="signal" aria-label="Signal Strength">
                    <i data-feather="activity"></i>
                    <span>Signal</span>
                </button>
            </div>
            
            <!-- Canvas Container -->
            <div id="canvas-container">
                <div id="konva-container"></div>
                
                <!-- Heatmap Controls -->
                <div id="heatmap-controls">
                    <label>
                        <input type="checkbox" id="heatmap-toggle" checked> Show Heatmap
                    </label>
                    <label>
                        <input type="checkbox" id="coverage-circles-toggle"> Show Coverage Circles
                    </label>
                    <label>
                        Opacity:
                        <input type="range" id="heatmap-opacity" min="0" max="100" value="70" style="width: 100px;">
                        <span class="slider-value" id="opacity-value">70%</span>
                    </label>
                    <label>
                        Resolution:
                        <select id="heatmap-resolution">
                            <option value="low">Low (Fast)</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High (Slow)</option>
                        </select>
                    </label>
                </div>
                
                <!-- Status Bar -->
                <div id="status-bar">
                    <span id="status-left">Ready</span>
                    <span id="status-right">Scale: 1.0 m/px</span>
                </div>

                <!-- Signal Tooltip -->
                <div id="signal-tooltip">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--primary-color);">Signal Strength</div>
                    <div id="signal-list"></div>
                </div>
                
                <!-- Loading Indicator -->
                <div class="loading" id="loading">
                    <div>Processing...</div>
                </div>
            </div>
            
            <!-- Right Inspector -->
            <div id="inspector">
                <div class="inspector-section">
                    <h3><i data-feather="info"></i> Selection Info</h3>
                    <div id="selection-info">
                        <p style="color: var(--text-secondary); font-size: 13px;">No object selected</p>
                    </div>
                </div>
                
                <div class="inspector-section" id="ap-config-section" style="display: none;">
                    <h3><i data-feather="wifi"></i> AP Configuration</h3>
                    <div class="form-group">
                        <label>Name</label>
                        <input type="text" id="ap-name" placeholder="AP Name">
                    </div>
                    <div class="form-group">
                        <label>Model</label>
                        <input type="text" id="ap-model" readonly>
                    </div>
                    <div class="form-group">
                        <label>SSID</label>
                        <input type="text" id="ap-ssid" placeholder="Network Name">
                    </div>
                    <div class="form-group">
                        <label>Height (ft)</label>
                        <input type="number" id="ap-height" step="0.1" min="0" max="30" value="9.0">
                    </div>
                    <div class="form-group">
                        <label>2.4 GHz TX Power (dBm): <span class="slider-value" id="tx-24-value">20</span></label>
                        <input type="range" id="ap-tx-24" min="0" max="20" value="20">
                    </div>
                    <div class="form-group">
                        <label>5 GHz TX Power (dBm): <span class="slider-value" id="tx-5-value">23</span></label>
                        <input type="range" id="ap-tx-5" min="0" max="23" value="23">
                    </div>
                    <div class="form-group">
                        <label>Channel (2.4 GHz)</label>
                        <select id="ap-channel-24">
                            <option value="1">Channel 1 (2412 MHz)</option>
                            <option value="6" selected>Channel 6 (2437 MHz)</option>
                            <option value="11">Channel 11 (2462 MHz)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Channel (5 GHz)</label>
                        <select id="ap-channel-5">
                            <option value="36" selected>Channel 36 (5180 MHz)</option>
                            <option value="40">Channel 40 (5200 MHz)</option>
                            <option value="44">Channel 44 (5220 MHz)</option>
                            <option value="149">Channel 149 (5745 MHz)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Antenna Type</label>
                        <select id="ap-antenna-type">
                            <option value="omni">Omnidirectional</option>
                            <option value="directional">Directional</option>
                        </select>
                    </div>
                    <div class="form-group" id="antenna-orientation-group" style="display: none;">
                        <label>Antenna Direction (degrees): <span class="slider-value" id="orientation-value">0</span></label>
                        <input type="range" id="ap-orientation" min="0" max="359" value="0">
                    </div>
                    <button class="btn btn-success" id="duplicate-ap-btn" style="width: 100%; margin-top: 8px;">
                        <i data-feather="copy"></i> Duplicate AP
                    </button>
                    <button class="btn btn-danger" id="delete-ap-btn" style="width: 100%; margin-top: 8px;">
                        <i data-feather="trash"></i> Delete AP
                    </button>
                </div>
                
                <div class="inspector-section">
                    <h3><i data-feather="users"></i> Client Simulation</h3>
                    <div class="form-group">
                        <label>Number of Clients: <span class="slider-value" id="client-count-value">50</span></label>
                        <input type="range" id="client-count" min="10" max="200" value="50" step="10">
                    </div>
                    <button class="btn btn-secondary" id="simulate-clients-btn" style="width: 100%;">
                        <i data-feather="zap"></i> Simulate Clients
                    </button>
                    <button class="btn btn-danger" id="clear-clients-btn" style="width: 100%; margin-top: 8px;">
                        <i data-feather="x"></i> Clear Clients
                    </button>
                </div>
                
                <div class="inspector-section">
                    <h3><i data-feather="bar-chart"></i> Statistics</h3>
                    <div id="stats-info" style="font-size: 13px; color: var(--text-secondary);">
                        <p>Building Area: <span id="stat-building-area" style="color: var(--primary-color); font-weight: 600;">0 sq ft</span></p>
                        <p>Interior Rooms: <span id="stat-rooms">0</span></p>
                        <p>APs: <span id="stat-aps">0</span></p>
                        <p>Walls: <span id="stat-walls">0</span></p>
                        <p>Clients: <span id="stat-clients">0</span></p>
                        <p>Coverage >-65dBm: <span id="stat-coverage">0%</span></p>
                    </div>
                </div>

                <div class="inspector-section">
                    <h3><i data-feather="wifi"></i> Internet Connection</h3>
                    <div class="form-group">
                        <label>Download Speed (Mbps)</label>
                        <input type="number" id="internet-download" value="1000" min="1" max="10000">
                    </div>
                    <div class="form-group">
                        <label>Upload Speed (Mbps)</label>
                        <input type="number" id="internet-upload" value="1000" min="1" max="10000">
                    </div>
                </div>                

                <div class="inspector-section">
                    <h3><i data-feather="radio"></i> Channel Planning</h3>
                    <button class="btn btn-secondary" id="auto-channel-btn" style="width: 100%;">
                        <i data-feather="zap"></i> Auto-Assign Channels
                    </button>
                    <button class="btn btn-secondary" id="show-interference-btn" style="width: 100%; margin-top: 8px;">
                        <i data-feather="alert-triangle"></i> Show Interference
                    </button>
                    <div id="channel-info" style="margin-top: 12px; font-size: 12px; color: var(--text-secondary);">
                        <p>Click "Auto-Assign" to optimize channels</p>
                    </div>
                </div>

                <div class="inspector-section" id="rooms-section">
                    <h3><i data-feather="grid"></i> Rooms</h3>
                    <div id="rooms-list" style="font-size: 13px; color: var(--text-secondary);">
                        <p>No rooms detected</p>
                    </div>
                </div>

                <div class="inspector-section" id="wall-config-section" style="display: none;">
                    <h3><i data-feather="layers"></i> Wall Configuration</h3>
                    <div class="form-group">
                        <label>Material Type</label>
                        <select id="wall-material">
                            <option value="3">Glass (3 dB)</option>
                            <option value="5">Wood (5 dB)</option>
                            <option value="8">Drywall (8 dB)</option>
                            <option value="12">Concrete (12 dB)</option>
                            <option value="15">Brick (15 dB)</option>
                            <option value="20">Metal/Elevator Shaft (20 dB)</option>
                        </select>
                    </div>
                    <button class="btn btn-success" id="apply-wall-material-change-btn" style="width: 100%; margin-top: 8px;">
                        <i data-feather="check"></i> Apply Material Change
                    </button>
                    <button class="btn btn-danger" id="delete-wall-btn" style="width: 100%; margin-top: 8px;">
                        <i data-feather="trash"></i> Delete Wall
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Device Library Modal -->
    <div class="modal" id="device-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Select Access Point / Router</h2>
                <button class="close-btn" id="close-device-modal">&times;</button>
            </div>
            
            <!-- Search and Filter Controls -->
            <div style="margin-bottom: 16px;">
                <div class="form-group" style="margin-bottom: 12px;">
                    <label>Search</label>
                    <input type="text" id="device-search" placeholder="Search by model name or type..." style="width: 100%;">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label>Filter by Vendor</label>
                    <select id="device-vendor-filter" style="width: 100%;">
                        <option value="all">All Vendors</option>
                    </select>
                </div>
            </div>
            
            <!-- Device count -->
            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                <span id="device-count">0 devices</span>
            </div>
            
            <div id="device-grid"></div>
        </div>
    </div>
    
    <!-- Scale Tool Modal -->
    <div class="modal" id="scale-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Set Scale</h2>
                <button class="close-btn" id="close-scale-modal">&times;</button>
            </div>
            <p style="margin-bottom: 16px; color: var(--text-secondary); font-size: 14px;">
                <strong>Step 1:</strong> Click two points on the canvas that you know the distance between.<br>
                <strong>Step 2:</strong> Enter the real-world distance in feet below.
            </p>
            <div class="form-group">
                <label>Click Status: <span id="scale-status" style="color: var(--primary-color);">Waiting for first point...</span></label>
            </div>
            <div class="form-group">
                <label>Measured Distance (pixels): <span id="scale-pixels" style="color: var(--primary-color);">0</span></label>
            </div>
            <div class="form-group">
                <label>Actual Distance (feet)</label>
                <input type="number" id="scale-distance" step="0.1" min="0.1" placeholder="e.g., 30.0">
            </div>
            <button class="btn btn-success" id="apply-scale-btn" style="width: 100%;" disabled>Apply Scale</button>
        </div>
    </div>
    
    <!-- Wall Material Modal -->
    <div class="modal" id="wall-material-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Select Wall Material</h2>
                <button class="close-btn" id="close-wall-material-modal">&times;</button>
            </div>
            <p style="margin-bottom: 16px; color: var(--text-secondary); font-size: 14px;">
                Choose the material type for this wall/room:
            </p>
            <div class="form-group">
                <label>Material Type</label>
                <select id="new-wall-material">
                    <option value="8" selected>Drywall (8 dB)</option>
                    <option value="12">Concrete (12 dB)</option>
                    <option value="15">Brick (15 dB)</option>
                    <option value="20">Metal/Elevator Shaft (20 dB)</option>
                    <option value="3">Glass (3 dB)</option>
                    <option value="5">Wood (5 dB)</option>
                </select>
            </div>
            <button class="btn btn-success" id="apply-wall-material-btn" style="width: 100%;">Apply Material</button>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="floor-plan-input" class="hidden-input" accept="image/*,.pdf">
    <input type="file" id="project-input" class="hidden-input" accept=".json">
    
    <script>
        // ===================================================================
        // DEVICE LIBRARY - Sample access points from various vendors
        // ===================================================================
const DEVICE_LIBRARY = [
            // Aruba Access Points
            {
                vendor: "Aruba",
                model: "AP-325 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 9.0
            },
            {
                vendor: "Aruba",
                model: "AP-515 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Aruba",
                model: "AP-555 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Aruba",
                model: "AP-635 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Aruba",
                model: "AP-655 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Aruba",
                model: "AP-505H (AP)",
                radios: [
                    { band: "2.4", maxTx: 18 },
                    { band: "5", maxTx: 20 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "Aruba",
                model: "AP-387 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 8, beamwidth: 45 },
                defaultHeight: 12.0
            },
            
            // Grandstream Access Points
            {
                vendor: "Grandstream",
                model: "GWN7630LR (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.2
            },
            {
                vendor: "Grandstream",
                model: "GWN7660 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 8.2
            },
            {
                vendor: "Grandstream",
                model: "GWN7664 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 8.2
            },
            {
                vendor: "Grandstream",
                model: "GWN7605 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.2
            },
            {
                vendor: "Grandstream",
                model: "GWN7600 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.2
            },
            {
                vendor: "Grandstream",
                model: "GWN7610 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.2
            },
            {
                vendor: "Grandstream",
                model: "GWN7602 (AP)",
                radios: [
                    { band: "2.4", maxTx: 18 },
                    { band: "5", maxTx: 20 }
                ],
                antenna: { type: "omni", gain: 2 },
                defaultHeight: 8.2
            },
            
            // Grandstream Routers
            {
                vendor: "Grandstream",
                model: "GWN7000 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Grandstream",
                model: "GWN7001 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            
            // MikroTik Access Points
            {
                vendor: "MikroTik",
                model: "cAP ac (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "MikroTik",
                model: "wAP ac (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 2 },
                defaultHeight: 8.5
            },
            {
                vendor: "MikroTik",
                model: "cAP XL ac (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.5
            },
            {
                vendor: "MikroTik",
                model: "Audience (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 9, beamwidth: 30 },
                defaultHeight: 12.0
            },
            {
                vendor: "MikroTik",
                model: "RBwAPG-5HacT2HnD (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 7, beamwidth: 60 },
                defaultHeight: 8.5
            },
            {
                vendor: "MikroTik",
                model: "BaseBox 5 (AP)",
                radios: [
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 10, beamwidth: 45 },
                defaultHeight: 12.0
            },
            {
                vendor: "MikroTik",
                model: "SXTsq 5 ac (AP)",
                radios: [
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 16, beamwidth: 30 },
                defaultHeight: 12.0
            },
            
            // MikroTik Routers with WiFi
            {
                vendor: "MikroTik",
                model: "hAP ac2 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 3.0
            },
            {
                vendor: "MikroTik",
                model: "hAP ax2 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "MikroTik",
                model: "hAP ax3 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // TP-Link Access Points
            {
                vendor: "TP-Link",
                model: "EAP225 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.2
            },
            {
                vendor: "TP-Link",
                model: "EAP245 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.2
            },
            {
                vendor: "TP-Link",
                model: "EAP620 HD (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.2
            },
            {
                vendor: "TP-Link",
                model: "EAP650 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.2
            },
            {
                vendor: "TP-Link",
                model: "EAP655 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.2
            },
            {
                vendor: "TP-Link",
                model: "EAP660 HD (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 8.2
            },
            {
                vendor: "TP-Link",
                model: "EAP615-Wall (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "TP-Link",
                model: "EAP225-Outdoor (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 12.0
            },
            {
                vendor: "TP-Link",
                model: "EAP610-Outdoor (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // TP-Link Routers
            {
                vendor: "TP-Link",
                model: "Archer AX55 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "TP-Link",
                model: "Archer AX73 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            {
                vendor: "TP-Link",
                model: "ER605 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // ===================================================================
            // UBIQUITI UNIFI ACCESS POINTS & ROUTERS
            // ===================================================================
            
            // UniFi 6 Series (WiFi 6 / 802.11ax)
            {
                vendor: "Ubiquiti",
                model: "U6-Lite (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "U6-LR (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "U6-Pro (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "U6-Enterprise (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "U6-Mesh (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 10.0
            },
            {
                vendor: "Ubiquiti",
                model: "U6-IW (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "Ubiquiti",
                model: "U6-Extender (AP)",
                radios: [
                    { band: "2.4", maxTx: 18 },
                    { band: "5", maxTx: 20 }
                ],
                antenna: { type: "omni", gain: 2 },
                defaultHeight: 5.0
            },
            
            // UniFi 7 Series (WiFi 7 / 802.11be)
            {
                vendor: "Ubiquiti",
                model: "U7-Pro (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 8.5
            },
            
            // UniFi AC Series (WiFi 5 / 802.11ac)
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-Lite (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-LR (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-Pro (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-HD (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-SHD (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-IW (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-M (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 10.0
            },
            {
                vendor: "Ubiquiti",
                model: "UAP-AC-M-Pro (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 10.0
            },
            
            // UniFi Outdoor APs
            {
                vendor: "Ubiquiti",
                model: "U6-Outdoor (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 12.0
            },
            {
                vendor: "Ubiquiti",
                model: "U6-LR-Outdoor (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // UniFi Building-to-Building (Directional)
            {
                vendor: "Ubiquiti",
                model: "UBB (AP)",
                radios: [
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 24, beamwidth: 25 },
                defaultHeight: 12.0
            },
            {
                vendor: "Ubiquiti",
                model: "UBB-XG (AP)",
                radios: [
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 26, beamwidth: 20 },
                defaultHeight: 12.0
            },
            
            // Dream Machine Series (Routers with built-in APs)
            {
                vendor: "Ubiquiti",
                model: "Dream Machine (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Ubiquiti",
                model: "Dream Machine Pro (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Ubiquiti",
                model: "Dream Machine SE (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Ubiquiti",
                model: "Dream Router (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Ubiquiti",
                model: "Dream Wall (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // AmpliFi Series (Consumer Routers)
            {
                vendor: "Ubiquiti",
                model: "AmpliFi HD (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Ubiquiti",
                model: "AmpliFi Instant (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Ubiquiti",
                model: "AmpliFi Alien (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
                        // ===================================================================
            // CISCO MERAKI - Enterprise Cloud-Managed (10 devices)
            // ===================================================================
            
            // WiFi 6 Indoor
            {
                vendor: "Cisco Meraki",
                model: "MR36 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Cisco Meraki",
                model: "MR46 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Cisco Meraki",
                model: "MR56 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Cisco Meraki",
                model: "MR57 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // WiFi 6E
            {
                vendor: "Cisco Meraki",
                model: "MR86 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "Cisco Meraki",
                model: "MR76 (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            {
                vendor: "Cisco Meraki",
                model: "MR86E (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            
            // Entry Level
            {
                vendor: "Cisco Meraki",
                model: "MR20 (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            
            // Security Appliances with WiFi
            {
                vendor: "Cisco Meraki",
                model: "MX67W (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Cisco Meraki",
                model: "MX68W (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // ===================================================================
            // RUCKUS NETWORKS - Enterprise (12 devices)
            // ===================================================================
            
            // WiFi 6 Indoor
            {
                vendor: "Ruckus",
                model: "R350 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Ruckus",
                model: "R550 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Ruckus",
                model: "R650 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Ruckus",
                model: "R750 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Ruckus",
                model: "R850 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 9.0
            },
            
            // WiFi 6E
            {
                vendor: "Ruckus",
                model: "R770 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "Ruckus",
                model: "T350c (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            {
                vendor: "Ruckus",
                model: "T750 (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            
            // Wall-plate
            {
                vendor: "Ruckus",
                model: "H350 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "Ruckus",
                model: "H550 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Budget/Entry
            {
                vendor: "Ruckus",
                model: "R320 (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Ruckus",
                model: "R510 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // ===================================================================
            // JUNIPER MIST - AI-Driven Enterprise (8 devices)
            // ===================================================================
            
            // WiFi 6
            {
                vendor: "Juniper Mist",
                model: "AP33 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Juniper Mist",
                model: "AP34 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Juniper Mist",
                model: "AP43 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Juniper Mist",
                model: "AP44 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // WiFi 6E
            {
                vendor: "Juniper Mist",
                model: "AP45 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "Juniper Mist",
                model: "AP63 (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // WiFi 5 (Legacy)
            {
                vendor: "Juniper Mist",
                model: "AP12 (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Juniper Mist",
                model: "AP21 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            
            // ===================================================================
            // FORTINET FortiAP - Security-Focused Enterprise (10 devices)
            // ===================================================================
            
            // WiFi 6 Indoor
            {
                vendor: "Fortinet",
                model: "FAP-231F (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Fortinet",
                model: "FAP-431F (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Fortinet",
                model: "FAP-433F (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Fortinet",
                model: "FAP-831F (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 9.0
            },
            
            // WiFi 6E
            {
                vendor: "Fortinet",
                model: "FAP-234F (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Fortinet",
                model: "FAP-234G (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "Fortinet",
                model: "FAP-221E (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            {
                vendor: "Fortinet",
                model: "FAP-423E (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            
            // Wall-plate
            {
                vendor: "Fortinet",
                model: "FAP-231G (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Entry Level
            {
                vendor: "Fortinet",
                model: "FAP-221C (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            // ===================================================================
            // EXTREME NETWORKS - Education & Enterprise (10 devices)
            // ===================================================================
            
            // WiFi 6E
            {
                vendor: "Extreme Networks",
                model: "AP4000 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Extreme Networks",
                model: "AP410C (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // WiFi 6
            {
                vendor: "Extreme Networks",
                model: "AP305C (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Extreme Networks",
                model: "AP3000 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Extreme Networks",
                model: "AP4000U (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // Wall-plate
            {
                vendor: "Extreme Networks",
                model: "AP302W (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Outdoor
            {
                vendor: "Extreme Networks",
                model: "AP3965e (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            {
                vendor: "Extreme Networks",
                model: "AP4000E (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            
            // Entry Level
            {
                vendor: "Extreme Networks",
                model: "AP122 (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            {
                vendor: "Extreme Networks",
                model: "AP250 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            
            // ===================================================================
            // CAMBIUM NETWORKS - Outdoor & WISP (12 devices)
            // ===================================================================
            
            // WiFi 6E Indoor
            {
                vendor: "Cambium Networks",
                model: "XV3-8 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // WiFi 6 Indoor
            {
                vendor: "Cambium Networks",
                model: "XV2-2 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Cambium Networks",
                model: "X4-8 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "Cambium Networks",
                model: "e600 (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            {
                vendor: "Cambium Networks",
                model: "e700 (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 7 },
                defaultHeight: 12.0
            },
            {
                vendor: "Cambium Networks",
                model: "e410 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            {
                vendor: "Cambium Networks",
                model: "e510 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // cnPilot Indoor
            {
                vendor: "Cambium Networks",
                model: "cnPilot e430H (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "Cambium Networks",
                model: "cnPilot e500 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // Point-to-Point
            {
                vendor: "Cambium Networks",
                model: "ePMP Force 300-25 (AP)",
                radios: [
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 25, beamwidth: 30 },
                defaultHeight: 12.0
            },
            {
                vendor: "Cambium Networks",
                model: "PTP 670 (AP)",
                radios: [
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 23, beamwidth: 35 },
                defaultHeight: 12.0
            },
            
            // Mesh
            {
                vendor: "Cambium Networks",
                model: "XV2-2T (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // ===================================================================
            // NETGEAR BUSINESS - SMB (12 devices)
            // ===================================================================
            
            // WiFi 6 High-End
            {
                vendor: "Netgear Business",
                model: "WAX630 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Netgear Business",
                model: "WAX620 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Netgear Business",
                model: "WAX610 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // WiFi 6E
            {
                vendor: "Netgear Business",
                model: "WAX630E (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            
            // WiFi 5
            {
                vendor: "Netgear Business",
                model: "WAC540 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Netgear Business",
                model: "WAC510 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 9.0
            },
            
            // Wall-plug
            {
                vendor: "Netgear Business",
                model: "WAX220 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            {
                vendor: "Netgear Business",
                model: "EAX20 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Outdoor
            {
                vendor: "Netgear Business",
                model: "WAX625 (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // Mesh Router (Orbi Pro)
            {
                vendor: "Netgear Business",
                model: "SXK80 Orbi Pro (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear Business",
                model: "SXK30 Orbi Pro (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // Entry
            {
                vendor: "Netgear Business",
                model: "WAX202 (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            
            // ===================================================================
            // ENGENIUS - Budget SMB (10 devices)
            // ===================================================================
            
            // WiFi 6
            {
                vendor: "EnGenius",
                model: "EWS377AP (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "EnGenius",
                model: "EWS357AP (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "EnGenius",
                model: "ECW336 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // Cloud-Managed
            {
                vendor: "EnGenius",
                model: "ECW230 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "EnGenius",
                model: "ECW220 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "EnGenius",
                model: "EWS860AP (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 12.0
            },
            {
                vendor: "EnGenius",
                model: "ENH1350EXT (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "directional", gain: 8, beamwidth: 60 },
                defaultHeight: 12.0
            },
            {
                vendor: "EnGenius",
                model: "ECW230S (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // Wall-plate
            {
                vendor: "EnGenius",
                model: "EWS310AP (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Budget
            {
                vendor: "EnGenius",
                model: "ECW120 (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            
            // ===================================================================
            // ZYXEL - SMB & Enterprise (10 devices)
            // ===================================================================
            
            // WiFi 6
            {
                vendor: "Zyxel",
                model: "WAX650S (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 9.0
            },
            {
                vendor: "Zyxel",
                model: "WAX640S (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Zyxel",
                model: "NWA210AX (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Zyxel",
                model: "WAX610D (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // WiFi 5
            {
                vendor: "Zyxel",
                model: "NWA1123-AC PRO (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "Zyxel",
                model: "WAC6552D-S (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // Outdoor
            {
                vendor: "Zyxel",
                model: "WAX510D (AP)",
                radios: [
                    { band: "2.4", maxTx: 21 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            {
                vendor: "Zyxel",
                model: "NWA1123-AC HD (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 12.0
            },
            
            // Wall-plate
            {
                vendor: "Zyxel",
                model: "WAX300H (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Entry
            {
                vendor: "Zyxel",
                model: "NWA90AX (AP)",
                radios: [
                    { band: "2.4", maxTx: 19 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 8.5
            },
            // ===================================================================
            // ASUS - Consumer & Gaming (15 devices)
            // ===================================================================
            
            // WiFi 6E Flagship
            {
                vendor: "ASUS",
                model: "GT-AXE16000 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "GT-AXE11000 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "RT-AXE7800 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // WiFi 6 Gaming (ROG)
            {
                vendor: "ASUS",
                model: "GT-AX11000 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "GT-AX6000 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "RT-AX86U Pro (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "RT-AX86U (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // WiFi 6 Mainstream
            {
                vendor: "ASUS",
                model: "RT-AX88U (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "RT-AX82U (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "RT-AX68U (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "RT-AX58U (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // Mesh Systems (ZenWiFi)
            {
                vendor: "ASUS",
                model: "ZenWiFi Pro XT12 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "ZenWiFi AX XT8 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "ASUS",
                model: "ZenWiFi AX6600 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // Budget WiFi 6
            {
                vendor: "ASUS",
                model: "RT-AX55 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // ===================================================================
            // NETGEAR CONSUMER - Nighthawk & Orbi (12 devices)
            // ===================================================================
            
            // Nighthawk WiFi 6E
            {
                vendor: "Netgear",
                model: "RAXE500 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RAXE300 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // Nighthawk WiFi 6
            {
                vendor: "Netgear",
                model: "RAX200 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RAX120 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RAX80 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RAX50 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RAX43 Nighthawk (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // Orbi WiFi 6E Mesh
            {
                vendor: "Netgear",
                model: "RBKE963 Orbi 960 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 6 },
                defaultHeight: 3.0
            },
            
            // Orbi WiFi 6 Mesh
            {
                vendor: "Netgear",
                model: "RBK852 Orbi (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RBK752 Orbi (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Netgear",
                model: "RBK753 Orbi (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // Gaming
            {
                vendor: "Netgear",
                model: "XR1000 Nighthawk Pro (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // ===================================================================
            // LINKSYS - Velop & Consumer (12 devices)
            // ===================================================================
            
            // WiFi 6E Mesh (Velop)
            {
                vendor: "Linksys",
                model: "MX6200 Velop (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Linksys",
                model: "MX5500 Velop (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // WiFi 6E Standalone
            {
                vendor: "Linksys",
                model: "E9450 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Linksys",
                model: "MR9610 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // WiFi 6 Mesh (Velop)
            {
                vendor: "Linksys",
                model: "MX5300 Velop (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Linksys",
                model: "MX4200 Velop (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "Linksys",
                model: "MR9600 Velop (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // Gaming
            {
                vendor: "Linksys",
                model: "WRT32X Gaming (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Linksys",
                model: "WRT3200ACM (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // WiFi 5 (Budget)
            {
                vendor: "Linksys",
                model: "EA9500 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "Linksys",
                model: "EA8300 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // Mesh WiFi 5 (Velop)
            {
                vendor: "Linksys",
                model: "WHW0303 Velop (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // ===================================================================
            // D-LINK - Budget Consumer (10 devices)
            // ===================================================================
            
            // WiFi 6E
            {
                vendor: "D-Link",
                model: "DIR-X6060 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            
            // WiFi 6
            {
                vendor: "D-Link",
                model: "DIR-X5460 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 5 },
                defaultHeight: 3.0
            },
            {
                vendor: "D-Link",
                model: "DIR-X4860 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            {
                vendor: "D-Link",
                model: "DIR-X1560 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // Mesh WiFi 6 (COVR)
            {
                vendor: "D-Link",
                model: "COVR-X1870 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            },
            
            // Range Extenders WiFi 6
            {
                vendor: "D-Link",
                model: "DAP-X2850 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 5.0
            },
            {
                vendor: "D-Link",
                model: "DAP-X1870 (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 3 },
                defaultHeight: 5.0
            },
            
            // Business APs
            {
                vendor: "D-Link",
                model: "DWL-8710AP (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 23 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            {
                vendor: "D-Link",
                model: "DWL-6610AP (AP)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 9.0
            },
            
            // WiFi 5 Budget
            {
                vendor: "D-Link",
                model: "DIR-882 (Router)",
                radios: [
                    { band: "2.4", maxTx: 20 },
                    { band: "5", maxTx: 22 }
                ],
                antenna: { type: "omni", gain: 4 },
                defaultHeight: 3.0
            }
        ];
        
        // ===================================================================
        // GLOBAL STATE
        // ===================================================================
        const APP_STATE = {
            projectName: "NetScope",
            currentTool: "select",
            viewMode: "2d",
            scale: 1.0,
            floorPlan: null,
            accessPoints: [],
            walls: [],
            obstacles: [],
            clients: [],
            selectedObject: null,
            heatmapEnabled: true,
            heatmapOpacity: 0.7,
            heatmapResolution: "medium",
            scaleLine: null,
            undoStack: [],
            pendingObject: null,
            gridEnabled: false,
            snapToGrid: true,
            gridSize: 20,
            measureLine: null,
            rooms: [],
            buildingArea: 0,
            showCoverageCircles: false,
            showInterference: false,
            showDensityHeatmap: false, 
            wallSnapDistance: 15
        };
        
        let stage, layer, heatmapLayer;
        let threeScene, threeCamera, threeRenderer;
        let heatmapUpdateTimer = null;
        
        // ===================================================================
        // INITIALIZATION
        // ===================================================================
        window.addEventListener('load', () => {
            // Configure PDF.js worker
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            
            // Wait a moment to ensure all scripts are loaded
            setTimeout(() => {
                // Check all required libraries
                const missingLibs = [];
                
                if (typeof Konva === 'undefined') {
                    missingLibs.push('Konva');
                }
                if (typeof THREE === 'undefined') {
                    missingLibs.push('THREE.js');
                }
                if (typeof feather === 'undefined') {
                    missingLibs.push('Feather Icons');
                }
                
                // Check jsPDF - it can be in different places depending on version
                const hasjsPDF = (typeof window.jspdf !== 'undefined' && window.jspdf.jsPDF) || 
                                (typeof jsPDF !== 'undefined') ||
                                (typeof window.jsPDF !== 'undefined');
                
                if (!hasjsPDF) {
                    missingLibs.push('jsPDF');
                }
                
                if (typeof saveAs === 'undefined') {
                    missingLibs.push('FileSaver');
                }
                
                if (missingLibs.length > 0) {
                    console.error('Missing libraries:', missingLibs);
                    console.log('window.jspdf:', window.jspdf);
                    console.log('window.jsPDF:', window.jsPDF);
                    console.log('Available globals:', Object.keys(window).filter(k => k.toLowerCase().includes('pdf')));
                    alert('Error: Failed to load libraries: ' + missingLibs.join(', ') + '. Please refresh the page.');
                    return;
                }
                
                console.log('All libraries loaded successfully');
                feather.replace();
                initializeKonva();
                setupEventListeners();
                setupKeyboardShortcuts();
                loadSampleProject();
                updateUI();
            }, 300); // Increased timeout to 300ms
        });
        
        function initializeKonva() {
            const container = document.getElementById('konva-container');
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            
            stage = new Konva.Stage({
                container: 'konva-container',
                width: width,
                height: height,
                draggable: false
            });
            
            // Background layer for floor plan
            const bgLayer = new Konva.Layer();
            stage.add(bgLayer);
            
            // Main layer for objects
            layer = new Konva.Layer();
            stage.add(layer);
            
            // Heatmap layer - DISABLE EVENT LISTENING
            heatmapLayer = new Konva.Layer({
                listening: false  // THIS IS THE KEY FIX!
            });
            stage.add(heatmapLayer);
            
            // Enable panning with space key
            let isPanning = false;
            let lastPos = null;
            
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !isPanning) {
                    isPanning = true;
                    stage.draggable(true);
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isPanning = false;
                    stage.draggable(false);
                }
            });
            
            // Zoom with mouse wheel
            stage.on('wheel', (e) => {
                e.evt.preventDefault();
                
                const oldScale = stage.scaleX();
                const pointer = stage.getPointerPosition();
                
                const mousePointTo = {
                    x: (pointer.x - stage.x()) / oldScale,
                    y: (pointer.y - stage.y()) / oldScale
                };
                
                const delta = e.evt.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(oldScale * delta, 5));
                
                stage.scale({ x: newScale, y: newScale });
                
                const newPos = {
                    x: pointer.x - mousePointTo.x * newScale,
                    y: pointer.y - mousePointTo.y * newScale
                };
                
                stage.position(newPos);
                stage.batchDraw();
            });

            // Track mouse movement for wall drawing visual feedback
            stage.on('mousemove', (e) => {
                if (APP_STATE.currentTool === 'wall') {
                    const pos = stage.getPointerPosition();
                    const transform = stage.getAbsoluteTransform().copy().invert();
                    const localPos = transform.point(pos);
                    
                    if (currentWall) {
                        updateWallDrawingVisuals(localPos);
                    } else {
                        // Show snap points when hovering over wall endpoints
                        showWallSnapPoints(localPos);
                    }
                }
            });

            // Prevent default context menu on stage (but allow bubbled events from objects)
            stage.on('contextmenu', (e) => {
                // Only prevent if not clicking on an object
                if (!e.target.parent || e.target.parent === stage) {
                    e.evt.preventDefault();
                }
            });

            stage.on('dblclick', (e) => {
                if (APP_STATE.currentTool === 'wall' && currentWall) {
                    finishWall();
                    updateStatus('Wall completed');
                }
            });
        }
        
        function drawGrid() {
            const gridLayer = stage.getLayers()[0]; // Use background layer
            
            // Remove old grid
            gridLayer.find('.grid-line').forEach(line => line.destroy());
            
            if (!APP_STATE.gridEnabled) {
                gridLayer.batchDraw();
                return;
            }
            
            const width = APP_STATE.floorPlan ? APP_STATE.floorPlan.width : stage.width();
            const height = APP_STATE.floorPlan ? APP_STATE.floorPlan.height : stage.height();
            const gridSize = APP_STATE.gridSize;
            
            // Vertical lines
            for (let x = 0; x <= width; x += gridSize) {
                const line = new Konva.Line({
                    points: [x, 0, x, height],
                    stroke: '#475569',
                    strokeWidth: 0.5,
                    opacity: 0.3,
                    name: 'grid-line'
                });
                gridLayer.add(line);
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += gridSize) {
                const line = new Konva.Line({
                    points: [0, y, width, y],
                    stroke: '#475569',
                    strokeWidth: 0.5,
                    opacity: 0.3,
                    name: 'grid-line'
                });
                gridLayer.add(line);
            }
            
            gridLayer.batchDraw();
        }
        
        function snapToGrid(pos) {
            if (!APP_STATE.snapToGrid || !APP_STATE.gridEnabled) return pos;
            
            const gridSize = APP_STATE.gridSize;
            return {
                x: Math.round(pos.x / gridSize) * gridSize,
                y: Math.round(pos.y / gridSize) * gridSize
            };
        }

        // ===================================================================
        // EVENT LISTENERS
        // ===================================================================
        function setupEventListeners() {
            // Topbar buttons
            document.getElementById('new-project-btn').addEventListener('click', newProject);
            document.getElementById('open-project-btn').addEventListener('click', openProject);
            document.getElementById('save-project-btn').addEventListener('click', saveProject);
            document.getElementById('export-pdf-btn').addEventListener('click', exportPDF);
            
            // Project name
            document.getElementById('project-name').addEventListener('input', (e) => {
                APP_STATE.projectName = e.target.value;
            });
            
            // Toolbar buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tool = btn.dataset.tool;
                    selectTool(tool);
                    
                    if (tool === 'upload') {
                        document.getElementById('floor-plan-input').click();
                    } else if (tool === 'ap') {
                        showDeviceLibrary();
                    }
                });
            });
            
            // Floor plan upload
            document.getElementById('floor-plan-input').addEventListener('change', handleFloorPlanUpload);
            
            // Project file upload
            document.getElementById('project-input').addEventListener('change', handleProjectLoad);
            
            // Heatmap controls
            document.getElementById('heatmap-toggle').addEventListener('change', (e) => {
                APP_STATE.heatmapEnabled = e.target.checked;
                updateHeatmap();
            });
            
            document.getElementById('heatmap-opacity').addEventListener('input', (e) => {
                APP_STATE.heatmapOpacity = e.target.value / 100;
                document.getElementById('opacity-value').textContent = e.target.value + '%';
                if (heatmapLayer) {
                    heatmapLayer.opacity(APP_STATE.heatmapOpacity);
                    heatmapLayer.batchDraw();
                }
            });
            
            document.getElementById('heatmap-resolution').addEventListener('change', (e) => {
                APP_STATE.heatmapResolution = e.target.value;
                updateHeatmap();
            });
            
            // Coverage circles toggle
            document.getElementById('coverage-circles-toggle').addEventListener('change', (e) => {
                APP_STATE.showCoverageCircles = e.target.checked;
                updateCoverageCircles();
            });

            // Inspector AP configuration
            const apInputs = ['ap-name', 'ap-ssid', 'ap-height', 'ap-tx-24', 'ap-tx-5', 'ap-channel-24', 'ap-channel-5', 'ap-antenna-type', 'ap-orientation'];
            apInputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', updateSelectedAP);
                    element.addEventListener('change', updateSelectedAP);
                }
            });
            
            // AP actions
            document.getElementById('duplicate-ap-btn').addEventListener('click', duplicateAP);
            document.getElementById('delete-ap-btn').addEventListener('click', deleteAP);
            
            // Client simulation
            document.getElementById('client-count').addEventListener('input', (e) => {
                document.getElementById('client-count-value').textContent = e.target.value;
            });
            document.getElementById('simulate-clients-btn').addEventListener('click', simulateClients);
            document.getElementById('clear-clients-btn').addEventListener('click', clearClients);
            
            // Modals
            document.getElementById('close-device-modal').addEventListener('click', () => {
                document.getElementById('device-modal').classList.remove('active');
            });
            
            document.getElementById('close-scale-modal').addEventListener('click', () => {
                document.getElementById('scale-modal').classList.remove('active');
            });
            
            document.getElementById('apply-scale-btn').addEventListener('click', applyScale);

            // Help button
            document.getElementById('help-btn').addEventListener('click', () => {
                const helpBox = document.getElementById('help-box');
                helpBox.style.display = helpBox.style.display === 'none' ? 'block' : 'none';
            });
            
            document.getElementById('close-help').addEventListener('click', () => {
                document.getElementById('help-box').style.display = 'none';
            });
            
            // Grid toggle
            document.getElementById('grid-toggle').addEventListener('change', (e) => {
                APP_STATE.gridEnabled = e.target.checked;
                drawGrid();
            });

            // Channel planning
            document.getElementById('auto-channel-btn').addEventListener('click', autoAssignChannels);
            document.getElementById('show-interference-btn').addEventListener('click', toggleInterferenceView);
            
            document.getElementById('snap-toggle').addEventListener('change', (e) => {
                APP_STATE.snapToGrid = e.target.checked;
            });
            
            // Export heatmap
            document.getElementById('export-heatmap-btn').addEventListener('click', exportHeatmapPNG);
            
            // Wall material
            document.getElementById('wall-material').addEventListener('change', updateSelectedWall);
            document.getElementById('delete-wall-btn').addEventListener('click', deleteWall);

            // Wall material modal
            document.getElementById('close-wall-material-modal').addEventListener('click', () => {
                document.getElementById('wall-material-modal').classList.remove('active');
                pendingWallForMaterial = null;
            });
            
            document.getElementById('apply-wall-material-btn').addEventListener('click', applyWallMaterial);

            // Canvas click for tools
            stage.on('click', handleCanvasClick);

            document.getElementById('density-heatmap-toggle').addEventListener('change', (e) => {
                APP_STATE.showDensityHeatmap = e.target.checked;
                updateDensityHeatmap();
            });

            // Wall material change button
            document.getElementById('apply-wall-material-change-btn').addEventListener('click', () => {
                if (!APP_STATE.selectedObject || APP_STATE.selectedObject.type !== 'wall') return;
                
                const wall = APP_STATE.selectedObject.object;
                const newMaterial = parseInt(document.getElementById('wall-material').value);
                wall.attenuation = newMaterial;
                
                // Update all rooms that use this wall
                APP_STATE.rooms.forEach(room => {
                    if (room.wallId === wall.id) {
                        room.material = newMaterial;
                    }
                });
                
                updateHeatmap();
                updateRoomsPanel();
                updateStatus(`Wall material changed to ${getMaterialName(newMaterial)}`);
            });
        }
        
        function updateDensityHeatmap() {
            heatmapLayer.find('.density-heatmap').forEach(h => h.destroy());
            
            if (!APP_STATE.showDensityHeatmap || APP_STATE.clients.length === 0) {
                heatmapLayer.batchDraw();
                return;
            }
            
            const width = APP_STATE.floorPlan ? APP_STATE.floorPlan.width : stage.width();
            const height = APP_STATE.floorPlan ? APP_STATE.floorPlan.height : stage.height();
            
            const gridSize = 50; // pixels
            const canvas = document.createElement('canvas');
            canvas.width = Math.ceil(width / gridSize);
            canvas.height = Math.ceil(height / gridSize);
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            // Count clients in each grid cell
            const grid = [];
            for (let y = 0; y < canvas.height; y++) {
                grid[y] = [];
                for (let x = 0; x < canvas.width; x++) {
                    grid[y][x] = 0;
                }
            }
            
            // Increment grid for each client
            APP_STATE.clients.forEach(client => {
                const gridX = Math.floor(client.x / gridSize);
                const gridY = Math.floor(client.y / gridSize);
                if (gridX >= 0 && gridX < canvas.width && gridY >= 0 && gridY < canvas.height) {
                    grid[gridY][gridX]++;
                }
            });
            
            // Find max density for normalization
            let maxDensity = 1;
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    maxDensity = Math.max(maxDensity, grid[y][x]);
                }
            }
            
            // Convert to colors
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const density = grid[y][x];
                    const normalized = density / maxDensity;
                    
                    const idx = (y * canvas.width + x) * 4;
                    // Blue to red gradient
                    data[idx] = Math.floor(255 * normalized);     // R
                    data[idx + 1] = 0;                             // G
                    data[idx + 2] = Math.floor(255 * (1 - normalized)); // B
                    data[idx + 3] = Math.floor(180 * normalized);  // A
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            const densityImage = new Konva.Image({
                image: canvas,
                width: width,
                height: height,
                opacity: 0.6,
                name: 'density-heatmap'
            });
            
            heatmapLayer.add(densityImage);
            heatmapLayer.batchDraw();
        }

        function autoAssignChannels() {
            if (APP_STATE.accessPoints.length === 0) {
                alert('No access points to configure');
                return;
            }
            
            // For 2.4 GHz, use channels 1, 6, 11 (non-overlapping)
            const channels24 = [1, 6, 11];
            // For 5 GHz, more options available
            const channels5 = [36, 40, 44, 48, 149, 153, 157, 161];
            
            // Simple greedy algorithm: assign channels to minimize interference
            APP_STATE.accessPoints.forEach((ap, index) => {
                // For 2.4 GHz - cycle through non-overlapping channels
                ap.config.channel24 = channels24[index % channels24.length];
                
                // For 5 GHz - find channel with least interference
                let bestChannel = channels5[0];
                let minInterference = Infinity;
                
                for (let channel of channels5) {
                    let interference = 0;
                    
                    // Check interference with other APs
                    APP_STATE.accessPoints.forEach(otherAP => {
                        if (otherAP.id === ap.id) return;
                        
                        const distance = Math.sqrt(
                            Math.pow(ap.x - otherAP.x, 2) + 
                            Math.pow(ap.y - otherAP.y, 2)
                        ) * APP_STATE.scale;
                        
                        // If on same channel and close, high interference
                        if (otherAP.config.channel5 === channel && distance < 100) {
                            interference += 100 / (distance + 1);
                        }
                        // Adjacent channel interference
                        else if (Math.abs(otherAP.config.channel5 - channel) <= 4 && distance < 50) {
                            interference += 20 / (distance + 1);
                        }
                    });
                    
                    if (interference < minInterference) {
                        minInterference = interference;
                        bestChannel = channel;
                    }
                }
                
                ap.config.channel5 = bestChannel;
            });
            
            // Update UI
            if (APP_STATE.selectedObject && APP_STATE.selectedObject.type === 'ap') {
                const ap = APP_STATE.selectedObject.object;
                document.getElementById('ap-channel-24').value = ap.config.channel24;
                document.getElementById('ap-channel-5').value = ap.config.channel5;
            }
            
            // Show channel assignments
            let info = '<p><strong>Channel Assignments:</strong></p>';
            APP_STATE.accessPoints.forEach(ap => {
                info += `<p>${ap.config.name}: 2.4G Ch${ap.config.channel24}, 5G Ch${ap.config.channel5}</p>`;
            });
            document.getElementById('channel-info').innerHTML = info;
            
            updateStatus('Channels auto-assigned');
            updateHeatmap();
        }

        function toggleInterferenceView() {
            APP_STATE.showInterference = !APP_STATE.showInterference;
            
            const btn = document.getElementById('show-interference-btn');
            if (APP_STATE.showInterference) {
                btn.classList.add('btn-warning');
                btn.classList.remove('btn-secondary');
                drawInterferenceLines();
            } else {
                btn.classList.remove('btn-warning');
                btn.classList.add('btn-secondary');
                layer.find('.interference-line').forEach(l => l.destroy());
                layer.batchDraw();
            }
        }

        function drawInterferenceLines() {
            // Remove existing interference lines
            layer.find('.interference-line').forEach(l => l.destroy());
            
            if (!APP_STATE.showInterference) return;
            
            // Draw lines between APs that interfere
            for (let i = 0; i < APP_STATE.accessPoints.length; i++) {
                for (let j = i + 1; j < APP_STATE.accessPoints.length; j++) {
                    const ap1 = APP_STATE.accessPoints[i];
                    const ap2 = APP_STATE.accessPoints[j];
                    
                    const distance = Math.sqrt(
                        Math.pow(ap1.x - ap2.x, 2) + 
                        Math.pow(ap1.y - ap2.y, 2)
                    ) * APP_STATE.scale;
                    
                    let interferenceLevel = null;
                    let color = '';
                    
                    // Check for co-channel interference
                    if (ap1.config.channel5 === ap2.config.channel5 && distance < 100) {
                        interferenceLevel = 'high';
                        color = '#ef4444';
                    }
                    // Adjacent channel
                    else if (Math.abs(ap1.config.channel5 - ap2.config.channel5) <= 4 && distance < 50) {
                        interferenceLevel = 'medium';
                        color = '#f59e0b';
                    }
                    
                    if (interferenceLevel) {
                        const line = new Konva.Line({
                            points: [ap1.x, ap1.y, ap2.x, ap2.y],
                            stroke: color,
                            strokeWidth: 3,
                            dash: [10, 5],
                            opacity: 0.6,
                            name: 'interference-line'
                        });
                        
                        layer.add(line);
                        line.moveToBottom();
                    }
                }
            }
            
            layer.batchDraw();
        }

        let snapPointIndicator = null;
        
        function showWallSnapPoints(mousePos) {
            const snapDist = APP_STATE.wallSnapDistance;
            let closestPoint = null;
            let minDist = Infinity;
            
            // Find nearest point on any wall
            for (let wall of APP_STATE.walls) {
                const points = wall.points;
                
                // Check each line segment
                for (let i = 0; i < points.length - 2; i += 2) {
                    const x1 = points[i];
                    const y1 = points[i + 1];
                    const x2 = points[i + 2];
                    const y2 = points[i + 3];
                    
                    const closest = closestPointOnLineSegment(mousePos.x, mousePos.y, x1, y1, x2, y2);
                    const dist = Math.sqrt(
                        Math.pow(mousePos.x - closest.x, 2) + 
                        Math.pow(mousePos.y - closest.y, 2)
                    );
                    
                    if (dist < snapDist && dist < minDist) {
                        minDist = dist;
                        closestPoint = { x: closest.x, y: closest.y };
                    }
                }
            }
            
            // Show indicator if near a snap point
            if (closestPoint) {
                if (snapPointIndicator) {
                    snapPointIndicator.destroy();
                }
                
                // Create a more visible snap indicator
                snapPointIndicator = new Konva.Group({
                    name: 'snap-indicator'
                });
                
                // Outer glow
                const outerCircle = new Konva.Circle({
                    x: closestPoint.x,
                    y: closestPoint.y,
                    radius: 12,
                    fill: '#10b981',
                    opacity: 0.3
                });
                
                // Inner circle
                const innerCircle = new Konva.Circle({
                    x: closestPoint.x,
                    y: closestPoint.y,
                    radius: 6,
                    fill: '#10b981',
                    stroke: '#fff',
                    strokeWidth: 2,
                    opacity: 0.9
                });
                
                snapPointIndicator.add(outerCircle);
                snapPointIndicator.add(innerCircle);
                
                layer.add(snapPointIndicator);
                layer.batchDraw();
            } else {
                if (snapPointIndicator) {
                    snapPointIndicator.destroy();
                    snapPointIndicator = null;
                    layer.batchDraw();
                }
            }
        }

        function updateCoverageCircles() {
            // Remove existing coverage circles
            layer.find('.coverage-circle').forEach(c => c.destroy());
            
            if (!APP_STATE.showCoverageCircles) {
                layer.batchDraw();
                return;
            }
            
            // Draw coverage circles for each AP
            APP_STATE.accessPoints.forEach(ap => {
                // Calculate radius for different signal levels
                const radii = [
                    { rssi: -50, color: '#10b981', opacity: 0.2, label: 'Excellent' },
                    { rssi: -65, color: '#84cc16', opacity: 0.2, label: 'Good' },
                    { rssi: -80, color: '#f59e0b', opacity: 0.15, label: 'Fair' }
                ];
                
                radii.forEach(level => {
                    const radius = calculateRadiusForRSSI(ap, level.rssi) / APP_STATE.scale;
                    
                    if (radius > 0 && radius < 10000) {
                        const circle = new Konva.Circle({
                            x: ap.x,
                            y: ap.y,
                            radius: radius,
                            stroke: level.color,
                            strokeWidth: 2,
                            dash: [10, 5],
                            fill: level.color,
                            opacity: level.opacity,
                            name: 'coverage-circle',
                            listening: false  // Don't intercept clicks
                        });
                        
                        layer.add(circle);
                        // Move to a layer between walls and heatmap
                        circle.moveToBottom();
                    }
                });
            });
            
            // Make sure walls and APs are on top
            layer.find('.wall').forEach(w => w.moveToTop());
            layer.find('.access-point').forEach(ap => ap.moveToTop());
            layer.find('.client-group').forEach(c => c.moveToTop());
            
            layer.batchDraw();
        }

        function calculateRadiusForRSSI(ap, targetRSSI) {
            // Work backwards from RSSI to find distance
            // RSSI = TxPower + AntennaGain - FSPL - WallLoss
            // For free space (no walls): FSPL = 20*log10(freq) + 20*log10(d) - 27.55
            // Solving for d: d = 10^((TxPower + Gain - RSSI - 20*log10(freq) + 27.55) / 20)
            
            const txPower = ap.config.tx5; // Use 5GHz
            const freq = 5180; // MHz
            const gain = ap.device.antenna.gain;
            
            const exponent = (txPower + gain - targetRSSI - 20 * Math.log10(freq) + 27.55) / 20;
            const distance = Math.pow(10, exponent); // Distance in feet
            
            return distance;
        }        

        function setupKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                // Ctrl+Z for undo
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    
                    // Special handling: if drawing a wall, remove last point
                    if (currentWall && currentWall.points.length > 2) {
                        // Remove last point (x,y pair)
                        currentWall.points.pop();
                        currentWall.points.pop();
                        
                        // Re-render the wall
                        layer.find('.temp-wall').forEach(w => w.destroy());
                        if (currentWall.points.length >= 2) {
                            renderWall(currentWall, true);
                        }
                        
                        updateStatus(`Wall: ${currentWall.points.length / 2} points - Ctrl+Z to remove last point`);
                    } else if (currentWall && currentWall.points.length === 2) {
                        // Cancel the wall if only one point left
                        layer.find('.temp-wall').forEach(w => w.destroy());
                        currentWall = null;
                        updateStatus('Wall cancelled');
                    } else {
                        // Normal undo for completed objects
                        undoLastAction();
                    }
                    return;
                }
                
                // Backspace as alternative to Ctrl+Z when drawing walls
                if (e.key === 'Backspace' && currentWall && currentWall.points.length > 2) {
                    // Don't trigger if in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    e.preventDefault();
                    
                    // Remove last point
                    currentWall.points.pop();
                    currentWall.points.pop();
                    
                    layer.find('.temp-wall').forEach(w => w.destroy());
                    if (currentWall.points.length >= 2) {
                        renderWall(currentWall, true);
                    }
                    
                    updateStatus(`Wall: ${currentWall.points.length / 2} points - Backspace to remove last point`);
                    return;
                }
                
                // Don't trigger other shortcuts if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key.toLowerCase()) {
                    case 'v':
                        selectTool('select');
                        break;
                    case 'a':
                        selectTool('ap');
                        showDeviceLibrary();
                        break;
                    case 'w':
                        selectTool('wall');
                        break;
                    case 'delete':
                        if (APP_STATE.selectedObject) {
                            deleteSelectedObject();
                        } else if (currentWall) {
                            // Delete cancels current wall drawing
                            layer.find('.temp-wall').forEach(w => w.destroy());
                            if (startPointIndicator) {
                                startPointIndicator.destroy();
                                startPointIndicator = null;
                            }
                            if (activeSnapIndicator) {
                                activeSnapIndicator.destroy();
                                activeSnapIndicator = null;
                            }
                            currentWall = null;
                            layer.batchDraw();
                            updateStatus('Wall drawing cancelled');
                        }
                        break;
                    case 'escape':
                        // Cancel current wall drawing
                        if (currentWall) {
                            layer.find('.temp-wall').forEach(w => w.destroy());
                            if (startPointIndicator) {
                                startPointIndicator.destroy();
                                startPointIndicator = null;
                            }
                            if (activeSnapIndicator) {
                                activeSnapIndicator.destroy();
                                activeSnapIndicator = null;
                            }
                            currentWall = null;
                            layer.batchDraw();
                            updateStatus('Wall drawing cancelled');
                        }
                        // Clear any measurement or scale lines
                        layer.find('.measure-point').forEach(p => p.destroy());
                        layer.find('.measure-line').forEach(l => l.destroy());
                        layer.find('.scale-point').forEach(p => p.destroy());
                        layer.find('.scale-line').forEach(l => l.destroy());
                        layer.batchDraw();
                        APP_STATE.measureLine = null;
                        APP_STATE.scaleLine = null;
                        
                        // Hide signal tooltip
                        document.getElementById('signal-tooltip').classList.remove('active');
                        
                        updateStatus('Actions cancelled');
                        break;
                }
            });
        }
        
        // ===================================================================
        // TOOL SELECTION
        // ===================================================================
        function selectTool(tool) {
            APP_STATE.currentTool = tool;
            
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => {
                if (btn.dataset.tool === tool) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update cursor
            const container = document.getElementById('konva-container');
            switch(tool) {
                case 'select':
                    container.style.cursor = 'default';
                    break;
                case 'wall':
                    container.style.cursor = 'crosshair';
                    break;
                case 'ap':
                case 'client':
                case 'obstacle':
                    container.style.cursor = 'copy';
                    break;
                case 'scale':
                container.style.cursor = 'crosshair';
                // Don't show modal yet - let user click points first
                updateStatus('Click first point on canvas for known distance');
                break;
            }
            
            updateStatus(`Tool: ${tool}`);
        }
        
        // ===================================================================
        // FLOOR PLAN UPLOAD
        // ===================================================================
        async function handleFloorPlanUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            showLoading(true);
            
            try {
                if (file.type === 'application/pdf') {
                    await loadPDFFloorPlan(file);
                } else {
                    await loadImageFloorPlan(file);
                }
                
                updateStatus('Floor plan loaded');
            } catch (error) {
                console.error('Error loading floor plan:', error);
                alert('Error loading floor plan: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        async function loadImageFloorPlan(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        APP_STATE.floorPlan = {
                            image: img,
                            width: img.width,
                            height: img.height,
                            dataURL: e.target.result
                        };
                        
                        renderFloorPlan();
                        resolve();
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        async function loadPDFFloorPlan(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1);
            
            const scale = 2;
            const viewport = page.getViewport({ scale });
            
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const context = canvas.getContext('2d');
            
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            
            const dataURL = canvas.toDataURL();
            const img = new Image();
            
            return new Promise((resolve, reject) => {
                img.onload = () => {
                    APP_STATE.floorPlan = {
                        image: img,
                        width: img.width,
                        height: img.height,
                        dataURL: dataURL
                    };
                    
                    renderFloorPlan();
                    resolve();
                };
                img.onerror = reject;
                img.src = dataURL;
            });
        }
        
        function renderFloorPlan() {
            const bgLayer = stage.getLayers()[0];
            bgLayer.destroyChildren();
            
            if (APP_STATE.floorPlan) {
                const image = new Konva.Image({
                    image: APP_STATE.floorPlan.image,
                    width: APP_STATE.floorPlan.width,
                    height: APP_STATE.floorPlan.height,
                    x: 0,
                    y: 0
                });
                
                bgLayer.add(image);
            }
            
            bgLayer.batchDraw();
            
            // Fit to stage
            fitToStage();
        }
        
        function fitToStage() {
            if (!APP_STATE.floorPlan) return;
            
            const containerWidth = stage.width();
            const containerHeight = stage.height();
            const imgWidth = APP_STATE.floorPlan.width;
            const imgHeight = APP_STATE.floorPlan.height;
            
            // Use 0.95 for 95% of space (more area filled), or 1.0 for 100%
            const scale = Math.min(containerWidth / imgWidth, containerHeight / imgHeight) * 0.95;
            
            stage.scale({ x: scale, y: scale });
            stage.position({
                x: (containerWidth - imgWidth * scale) / 2,
                y: (containerHeight - imgHeight * scale) / 2
            });
            stage.batchDraw();
        }
        
        // ===================================================================
        // DEVICE LIBRARY
        // ===================================================================
        function showDeviceLibrary() {
            const modal = document.getElementById('device-modal');
            const grid = document.getElementById('device-grid');
            const vendorFilter = document.getElementById('device-vendor-filter');
            const searchInput = document.getElementById('device-search');
            
            // Get unique vendors
            const vendors = [...new Set(DEVICE_LIBRARY.map(d => d.vendor))].sort();
            
            // Populate vendor dropdown
            vendorFilter.innerHTML = '<option value="all">All Vendors</option>';
            vendors.forEach(vendor => {
                const option = document.createElement('option');
                option.value = vendor;
                option.textContent = vendor;
                vendorFilter.appendChild(option);
            });
            
            // Function to filter and render devices
            function renderDevices() {
                const selectedVendor = vendorFilter.value;
                const searchTerm = searchInput.value.toLowerCase().trim();
                
                // Filter devices
                let filteredDevices = DEVICE_LIBRARY.filter(device => {
                    const matchesVendor = selectedVendor === 'all' || device.vendor === selectedVendor;
                    const matchesSearch = searchTerm === '' || 
                        device.model.toLowerCase().includes(searchTerm) ||
                        device.vendor.toLowerCase().includes(searchTerm);
                    return matchesVendor && matchesSearch;
                });
                
                // Update device count
                const countText = filteredDevices.length === 1 ? '1 device' : `${filteredDevices.length} devices`;
                document.getElementById('device-count').textContent = countText;
                
                // Clear grid
                grid.innerHTML = '';
                
                if (filteredDevices.length === 0) {
                    const noResults = document.createElement('div');
                    noResults.style.cssText = 'text-align: center; padding: 40px; color: var(--text-secondary);';
                    noResults.innerHTML = '<p>No devices found</p><p style="font-size: 12px; margin-top: 8px;">Try a different search or filter</p>';
                    grid.appendChild(noResults);
                    return;
                }
                
                // Group by vendor
                const byVendor = {};
                filteredDevices.forEach(device => {
                    if (!byVendor[device.vendor]) {
                        byVendor[device.vendor] = [];
                    }
                    byVendor[device.vendor].push(device);
                });
                
                // Render devices grouped by vendor
                Object.keys(byVendor).sort().forEach(vendor => {
                    // Only show vendor header if showing all vendors
                    if (selectedVendor === 'all') {
                        const vendorHeader = document.createElement('div');
                        vendorHeader.style.cssText = 'font-weight: 600; margin-top: 16px; margin-bottom: 8px; color: var(--primary-color); font-size: 14px; border-bottom: 1px solid var(--border-color); padding-bottom: 4px;';
                        vendorHeader.textContent = vendor;
                        grid.appendChild(vendorHeader);
                    }
                    
                    byVendor[vendor].forEach(device => {
                        const item = document.createElement('div');
                        item.className = 'device-item';
                        
                        // Determine if it's a router or AP
                        const isRouter = device.model.toLowerCase().includes('router');
                        const deviceIcon = isRouter ? '' : '';
                        
                        // Build radio specs string
                        const radios = device.radios.map(r => `${r.band}GHz (${r.maxTx}dBm)`).join(', ');
                        
                        // Build antenna info
                        const antennaInfo = device.antenna.type === 'directional' 
                            ? `${device.antenna.type} (+${device.antenna.gain}dBi, ${device.antenna.beamwidth})`
                            : `${device.antenna.type} (+${device.antenna.gain}dBi)`;
                        
                        item.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 20px;">${deviceIcon}</span>
                                <div style="flex: 1;">
                                    <div class="device-name">${device.model}</div>
                                    <div class="device-specs">${radios}</div>
                                    <div class="device-specs">Antenna: ${antennaInfo}</div>
                                </div>
                            </div>
                        `;
                        
                        item.addEventListener('click', () => {
                            APP_STATE.pendingObject = { type: 'ap', device: device };
                            modal.classList.remove('active');
                            updateStatus('Click on canvas to place ' + (isRouter ? 'router' : 'AP'));
                            document.getElementById('konva-container').style.cursor = 'crosshair';
                        });
                        
                        grid.appendChild(item);
                    });
                });
            }
            
            // Initial render
            renderDevices();
            
            // Add event listeners for filtering
            vendorFilter.addEventListener('change', renderDevices);
            searchInput.addEventListener('input', renderDevices);
            
            // Clear search when modal opens
            searchInput.value = '';
            vendorFilter.value = 'all';
            
            modal.classList.add('active');
            
            // Focus search box for quick typing
            setTimeout(() => searchInput.focus(), 100);
            
            feather.replace();
        }
        
        // ===================================================================
        // ACCESS POINT MANAGEMENT
        // ===================================================================
        function addAccessPoint(device, x = null, y = null) {
            const id = 'ap_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // x and y must be provided - no auto-centering
            if (x === null || y === null) {
                console.error('AP position must be specified');
                return null;
            }
            
            const ap = {
                id: id,
                x: x,
                y: y,
                device: device,
                config: {
                    name: `${device.vendor} ${device.model}`,
                    ssid: 'WiFi Network',
                    height: device.defaultHeight,
                    tx24: device.radios.find(r => r.band === '2.4')?.maxTx || 20,
                    tx5: device.radios.find(r => r.band === '5')?.maxTx || 23,
                    channel24: 6,
                    channel5: 36,
                    antennaType: device.antenna.type,
                    orientation: 0
                },
                angle: 0
            };
            
            APP_STATE.accessPoints.push(ap);
            renderAP(ap);
            saveUndoState('addAP', ap);
            updateHeatmap();
            updateStats();
            
            return ap;
        }
        
        function updateClientLines() {
            // Remove all existing client lines
            layer.find('.client-line').forEach(l => l.destroy());
            
            // Redraw all client connections
            APP_STATE.clients.forEach(client => {
                const clientGroup = layer.findOne('#' + client.id);
                if (!clientGroup) return;
                
                const ap = APP_STATE.accessPoints.find(a => a.id === client.connectedAP);
                if (ap) {
                    const line = new Konva.Line({
                        points: [client.x, client.y, ap.x, ap.y],
                        stroke: '#1a4503',
                        strokeWidth: 2,
                        opacity: 0.5,
                        dash: [8, 4],
                        name: 'client-line',
                        listening: false
                    });
                    
                    // Insert line at the beginning of the group (behind the circle)
                    clientGroup.add(line);
                    line.moveToBottom();
                }
            });
            
            layer.batchDraw();
        }
        
        function renderAP(ap) {
            // Remove any existing AP with this ID first
            const existing = layer.findOne('#' + ap.id);
            if (existing) existing.destroy();
            
            // Determine if this is a router or AP
            const isRouter = ap.device.model.toLowerCase().includes('router');
            const deviceLabel = isRouter ? 'Router' : 'AP';
            
            // Create AP visual
            const group = new Konva.Group({
                x: ap.x,
                y: ap.y,
                draggable: true,
                id: ap.id,
                name: 'access-point'
            });
            
            // Background circle
            const circle = new Konva.Circle({
                radius: 15,
                fill: isRouter ? '#8b5cf6' : '#3b82f6', // Purple for routers, blue for APs
                stroke: isRouter ? '#6d28d9' : '#1e40af',
                strokeWidth: 2,
                shadowColor: 'black',
                shadowBlur: 10,
                shadowOpacity: 0.6,
                name: 'ap-circle'
            });
            
            // WiFi icon (simplified)
            const arc1 = new Konva.Arc({
                innerRadius: 5,
                outerRadius: 7,
                angle: 180,
                rotation: -90,
                fill: 'white'
            });
            
            const arc2 = new Konva.Arc({
                innerRadius: 9,
                outerRadius: 11,
                angle: 180,
                rotation: -90,
                fill: 'white',
                opacity: 0.7
            });
            
            group.add(circle);
            group.add(arc1);
            group.add(arc2);
            
            // Direction indicator for directional antennas
            if (ap.device.antenna.type === 'directional') {
                const indicator = new Konva.Line({
                    points: [0, 0, 25, 0],
                    stroke: '#f59e0b',
                    strokeWidth: 3,
                    rotation: ap.config.orientation
                });
                group.add(indicator);
            }
            
            // Device type label (AP or Router)
            const typeLabel = new Konva.Text({
                text: deviceLabel,
                fontSize: 10,
                fontStyle: 'bold',
                fill: 'white',
                y: -25,
                x: -15,
                width: 30,
                align: 'center',
                shadowColor: 'black',
                shadowBlur: 3,
                shadowOpacity: 0.8
            });
            group.add(typeLabel);
            
            // Name label
            const label = new Konva.Text({
                text: ap.config.name,
                fontSize: 12,
                fill: 'white',
                y: 20,
                x: -50,
                width: 100,
                align: 'center',
                shadowColor: 'black',
                shadowBlur: 5,
                shadowOpacity: 0.8
            });
            group.add(label);
            
            // Event handlers
            group.on('dragstart', () => {
                group.moveToTop();
                circle.stroke('#f59e0b');
                circle.strokeWidth(4);
                document.getElementById('konva-container').style.cursor = 'grabbing';
                layer.batchDraw();
            });
            
            group.on('dragmove', () => {
                ap.x = group.x();
                ap.y = group.y();
                
                // Update client connection lines in real-time
                updateClientLines();
                
                // Update coverage circles if visible
                if (APP_STATE.showCoverageCircles) {
                    updateCoverageCircles();
                }
                
                // Update position display in real-time
                if (APP_STATE.selectedObject && APP_STATE.selectedObject.object.id === ap.id) {
                    document.getElementById('selection-info').innerHTML = `
                        <p><strong>Type:</strong> ${deviceLabel}</p>
                        <p><strong>Position:</strong> (${ap.x.toFixed(1)}, ${ap.y.toFixed(1)})</p>
                    `;
                }
                
                scheduleHeatmapUpdate();
            });
            
            group.on('dragend', () => {
                circle.stroke(isRouter ? '#6d28d9' : '#1e40af');
                circle.strokeWidth(2);
                document.getElementById('konva-container').style.cursor = 'default';
                ap.x = group.x();
                ap.y = group.y();
                
                // Final update of client lines
                updateClientLines();
                
                updateHeatmap();
                updateStatus(`${deviceLabel} moved to (${ap.x.toFixed(1)}, ${ap.y.toFixed(1)})`);
                layer.batchDraw();
            });
            
            group.on('click tap', (e) => {
                e.cancelBubble = true;
                selectObject(ap, 'ap');
                
                circle.stroke('#f59e0b');
                circle.strokeWidth(4);
                layer.batchDraw();
                
                updateStatus(`Selected: ${ap.config.name}`);
            });
            
            // Right-click to delete
            group.on('contextmenu', (e) => {
                e.evt.preventDefault();
                e.cancelBubble = true;
                
                if (confirm(`Delete ${ap.config.name}?`)) {
                    const index = APP_STATE.accessPoints.findIndex(a => a.id === ap.id);
                    if (index > -1) {
                        APP_STATE.accessPoints.splice(index, 1);
                    }
                    group.destroy();
                    
                    // Remove associated client lines
                    updateClientLines();
                    
                    layer.batchDraw();
                    APP_STATE.selectedObject = null;
                    updateUI();
                    updateHeatmap();
                    updateStats();
                    updateStatus(`${deviceLabel} deleted`);
                }
            });
            
            // Hover effects
            group.on('mouseenter', () => {
                document.getElementById('konva-container').style.cursor = 'pointer';
                if (!group.isDragging()) {
                    circle.strokeWidth(3);
                    layer.batchDraw();
                }
            });
            
            group.on('mouseleave', () => {
                if (APP_STATE.currentTool === 'select') {
                    document.getElementById('konva-container').style.cursor = 'default';
                }
                if (!group.isDragging() && (!APP_STATE.selectedObject || APP_STATE.selectedObject.object.id !== ap.id)) {
                    circle.strokeWidth(2);
                    layer.batchDraw();
                }
            });
            
            layer.add(group);
            layer.batchDraw();
        }
        
        function updateSelectedAP() {
            if (!APP_STATE.selectedObject || APP_STATE.selectedObject.type !== 'ap') return;
            
            const ap = APP_STATE.selectedObject.object;
            
            // Update config from form
            ap.config.name = document.getElementById('ap-name').value;
            ap.config.ssid = document.getElementById('ap-ssid').value;
            ap.config.height = parseFloat(document.getElementById('ap-height').value);
            ap.config.tx24 = parseInt(document.getElementById('ap-tx-24').value);
            ap.config.tx5 = parseInt(document.getElementById('ap-tx-5').value);
            ap.config.channel24 = parseInt(document.getElementById('ap-channel-24').value);
            ap.config.channel5 = parseInt(document.getElementById('ap-channel-5').value);
            ap.config.antennaType = document.getElementById('ap-antenna-type').value;
            ap.config.orientation = parseInt(document.getElementById('ap-orientation').value);
            
            // Update UI values
            document.getElementById('tx-24-value').textContent = ap.config.tx24;
            document.getElementById('tx-5-value').textContent = ap.config.tx5;
            document.getElementById('orientation-value').textContent = ap.config.orientation;
            
            // Show/hide orientation control
            const orientationGroup = document.getElementById('antenna-orientation-group');
            if (ap.config.antennaType === 'directional') {
                orientationGroup.style.display = 'block';
            } else {
                orientationGroup.style.display = 'none';
            }
            
            // Re-render AP
            const group = layer.findOne('#' + ap.id);
            if (group) {
                group.destroy();
            }
            renderAP(ap);
            
            scheduleHeatmapUpdate();
        }
        
        function duplicateAP() {
            if (!APP_STATE.selectedObject || APP_STATE.selectedObject.type !== 'ap') return;
            
            const original = APP_STATE.selectedObject.object;
            const device = original.device;
            
            const newAP = addAccessPoint(device, original.x + 50, original.y + 50);
            newAP.config = { ...original.config };
            newAP.config.name += ' (Copy)';
            
            selectObject(newAP, 'ap');
        }
        
        function deleteAP() {
            if (!APP_STATE.selectedObject || APP_STATE.selectedObject.type !== 'ap') {
                alert('No access point selected');
                return;
            }
            
            const ap = APP_STATE.selectedObject.object;
            
            if (confirm(`Delete ${ap.config.name}?`)) {
                // Remove from array
                const index = APP_STATE.accessPoints.findIndex(a => a.id === ap.id);
                if (index > -1) {
                    APP_STATE.accessPoints.splice(index, 1);
                }
                
                // Remove from canvas
                const group = layer.findOne('#' + ap.id);
                if (group) {
                    group.destroy();
                }
                
                // Also try to remove by name in case ID didn't work
                layer.find('.access-point').forEach(node => {
                    if (node.attrs.id === ap.id) {
                        node.destroy();
                    }
                });
                
                layer.batchDraw();
                
                // Clear selection
                APP_STATE.selectedObject = null;
                document.getElementById('ap-config-section').style.display = 'none';
                
                updateUI();
                updateHeatmap();
                updateStats();
                updateStatus('AP deleted');
            }
        }
        
        function showSignalStrength(x, y, screenX, screenY) {
            if (APP_STATE.accessPoints.length === 0) {
                alert('No access points placed yet');
                return;
            }
            
            const tooltip = document.getElementById('signal-tooltip');
            const list = document.getElementById('signal-list');
            
            list.innerHTML = '';
            
            // Calculate signal from each AP
            const signals = APP_STATE.accessPoints.map(ap => {
                const rssi5 = calculateRSSI(ap, x, y, '5');
                const rssi24 = calculateRSSI(ap, x, y, '2.4');
                return {
                    name: ap.config.name,
                    rssi5: rssi5,
                    rssi24: rssi24,
                    best: Math.max(rssi5, rssi24)
                };
            });
            
            // Sort by strongest signal
            signals.sort((a, b) => b.best - a.best);
            
            signals.forEach(sig => {
                const quality = sig.best > -50 ? 'signal-strong' :
                               sig.best > -65 ? 'signal-good' :
                               sig.best > -80 ? 'signal-fair' : 'signal-weak';
                
                const item = document.createElement('div');
                item.className = `signal-item ${quality}`;
                item.innerHTML = `
                    <span>${sig.name}</span>
                    <span>${sig.best.toFixed(1)} dBm</span>
                `;
                list.appendChild(item);
            });
            
            tooltip.style.left = (screenX + 20) + 'px';
            tooltip.style.top = (screenY + 20) + 'px';
            tooltip.classList.add('active');
            
            // Hide after 3 seconds
            setTimeout(() => {
                tooltip.classList.remove('active');
            }, 3000);
        }

        // ===================================================================
        // WALL DRAWING
        // ===================================================================
        let currentWall = null;
        
        function handleCanvasClick(e) {
            const pos = stage.getPointerPosition();
            const transform = stage.getAbsoluteTransform().copy().invert();
            let localPos = transform.point(pos);
            
            // Apply snap to grid if enabled
            if (APP_STATE.snapToGrid && APP_STATE.gridEnabled) {
                localPos = snapToGrid(localPos);
            }
            
            // Handle pending AP placement - MUST BE FIRST
            if (APP_STATE.pendingObject && APP_STATE.pendingObject.type === 'ap') {
                const device = APP_STATE.pendingObject.device;
                addAccessPoint(device, localPos.x, localPos.y);
                APP_STATE.pendingObject = null;
                selectTool('select');
                updateStatus('AP placed');
                return;
            }
            
            // Measurement tool
            if (APP_STATE.currentTool === 'measure') {
                if (!APP_STATE.measureLine) {
                    APP_STATE.measureLine = {
                        start: localPos,
                        end: null
                    };
                    
                    const point = new Konva.Circle({
                        x: localPos.x,
                        y: localPos.y,
                        radius: 8,  // Increased from 6
                        fill: '#10b981',
                        stroke: '#fff',
                        strokeWidth: 3,  // Increased from 2
                        shadowColor: 'black',
                        shadowBlur: 5,
                        name: 'measure-point'
                    });
                    layer.add(point);
                    layer.batchDraw();
                    updateStatus('Click second point to measure');
                } else {
                    APP_STATE.measureLine.end = localPos;
                    
                    const dx = APP_STATE.measureLine.end.x - APP_STATE.measureLine.start.x;
                    const dy = APP_STATE.measureLine.end.y - APP_STATE.measureLine.start.y;
                    const pixels = Math.sqrt(dx * dx + dy * dy);
                    const distance = pixels * APP_STATE.scale;
                    
                    const point = new Konva.Circle({
                        x: localPos.x,
                        y: localPos.y,
                        radius: 8,  // Increased from 6
                        fill: '#10b981',
                        stroke: '#fff',
                        strokeWidth: 3,  // Increased from 2
                        shadowColor: 'black',
                        shadowBlur: 5,
                        name: 'measure-point'
                    });
                    layer.add(point);
                    
                    const line = new Konva.Line({
                        points: [APP_STATE.measureLine.start.x, APP_STATE.measureLine.start.y,
                                APP_STATE.measureLine.end.x, APP_STATE.measureLine.end.y],
                        stroke: '#10b981',
                        strokeWidth: 4,  // Increased from 3
                        dash: [10, 5],
                        shadowColor: 'black',
                        shadowBlur: 3,
                        name: 'measure-line'
                    });
                    layer.add(line);
                    
                    const midX = (APP_STATE.measureLine.start.x + APP_STATE.measureLine.end.x) / 2;
                    const midY = (APP_STATE.measureLine.start.y + APP_STATE.measureLine.end.y) / 2;
                    
                    // Create a background for the label
                    const labelBg = new Konva.Rect({
                        x: midX - 60,
                        y: midY - 30,
                        width: 120,
                        height: 40,
                        fill: '#10b981',
                        cornerRadius: 6,
                        shadowColor: 'black',
                        shadowBlur: 10,
                        shadowOpacity: 0.5,
                        name: 'measure-line'
                    });
                    layer.add(labelBg);
                    
                    const label = new Konva.Text({
                        x: midX - 60,
                        y: midY - 20,
                        width: 120,
                        text: `${distance.toFixed(2)} ft`,
                        fontSize: 18,  // Increased from 16
                        fontStyle: 'bold',
                        fill: '#fff',
                        align: 'center',
                        name: 'measure-line'
                    });
                    layer.add(label);
                    layer.batchDraw();
                    
                    updateStatus(`Distance: ${distance.toFixed(2)} feet (${pixels.toFixed(1)} px) - Click anywhere or press ESC to clear`);
                    
                    // Keep measurement visible longer - 10 seconds instead of 3
                    setTimeout(() => {
                        layer.find('.measure-point').forEach(p => p.destroy());
                        layer.find('.measure-line').forEach(l => l.destroy());
                        layer.batchDraw();
                        APP_STATE.measureLine = null;
                        updateStatus('Measurement cleared');
                    }, 10000);  // Changed from 3000 to 10000
                }
                return;
            }
            
            // Signal strength tool
            if (APP_STATE.currentTool === 'signal') {
                showSignalStrength(localPos.x, localPos.y, pos.x, pos.y);
                return;
            }
            
            // Handle pending obstacle placement
            if (APP_STATE.currentTool === 'obstacle') {
                addObstacle(localPos.x, localPos.y);
                return;
            }

            if (APP_STATE.currentTool === 'client') {
                addSingleClient(localPos.x, localPos.y);
                return;
            }

            if (APP_STATE.currentTool === 'wall') {
                // Snap to existing wall endpoints/segments
                const snappedPos = snapToWallEndpoint(localPos);
                
                if (!currentWall) {
                    // Start new wall
                    currentWall = {
                        id: 'wall_' + Date.now(),
                        points: [snappedPos.x, snappedPos.y],
                        attenuation: 8
                    };
                    updateStatus('Click to add points. Ctrl+Z to remove last point. Double-click to finish.');
                } else {
                    const startX = currentWall.points[0];
                    const startY = currentWall.points[1];
                    const distToStart = Math.sqrt(Math.pow(snappedPos.x - startX, 2) + Math.pow(snappedPos.y - startY, 2));
                    
                    // Check if snapping to an existing wall (to complete a room)
                    let snappedToExistingWall = false;
                    const snapDist = APP_STATE.wallSnapDistance;
                    
                    for (let wall of APP_STATE.walls) {
                        const points = wall.points;
                        
                        for (let i = 0; i < points.length - 2; i += 2) {
                            const x1 = points[i];
                            const y1 = points[i + 1];
                            const x2 = points[i + 2];
                            const y2 = points[i + 3];
                            
                            const closest = closestPointOnLineSegment(snappedPos.x, snappedPos.y, x1, y1, x2, y2);
                            const dist = Math.sqrt(
                                Math.pow(snappedPos.x - closest.x, 2) + 
                                Math.pow(snappedPos.y - closest.y, 2)
                            );
                            
                            if (dist < snapDist) {
                                // Snap to this wall and complete the room
                                currentWall.points.push(closest.x, closest.y);
                                snappedToExistingWall = true;
                                finishWall(true); // true = closed room
                                updateStatus('Room completed by connecting to existing wall');
                                return;
                            }
                        }
                    }
                    
                    // Check if closing back to start point
                    if (distToStart < 20 && currentWall.points.length >= 6) {
                        currentWall.points.push(startX, startY);
                        finishWall(true); // true = closed wall
                        updateStatus('Wall closed');
                        return;
                    }
                    
                    // Add regular point
                    currentWall.points.push(snappedPos.x, snappedPos.y);
                    renderWall(currentWall, true);
                    updateStatus(`Wall: ${currentWall.points.length / 2} points. Ctrl+Z to remove last. Double-click to finish.`);
                }
                return;
            }
            
            else if (APP_STATE.currentTool === 'scale') {
                if (!pos || !localPos) return;
                
                if (!APP_STATE.scaleLine) {
                    APP_STATE.scaleLine = {
                        start: localPos,
                        end: null
                    };
                    
                    const point = new Konva.Circle({
                        x: localPos.x,
                        y: localPos.y,
                        radius: 8,
                        fill: '#ef4444',
                        stroke: '#fff',
                        strokeWidth: 2,
                        name: 'scale-point'
                    });
                    layer.add(point);
                    layer.batchDraw();
                    
                    updateStatus('Click second point on canvas');
                } else {
                    APP_STATE.scaleLine.end = localPos;
                    
                    const dx = APP_STATE.scaleLine.end.x - APP_STATE.scaleLine.start.x;
                    const dy = APP_STATE.scaleLine.end.y - APP_STATE.scaleLine.start.y;
                    const pixels = Math.sqrt(dx * dx + dy * dy);
                    
                    const point = new Konva.Circle({
                        x: localPos.x,
                        y: localPos.y,
                        radius: 8,
                        fill: '#ef4444',
                        stroke: '#fff',
                        strokeWidth: 2,
                        name: 'scale-point'
                    });
                    layer.add(point);
                    
                    const line = new Konva.Line({
                        points: [APP_STATE.scaleLine.start.x, APP_STATE.scaleLine.start.y, 
                                APP_STATE.scaleLine.end.x, APP_STATE.scaleLine.end.y],
                        stroke: '#ef4444',
                        strokeWidth: 4,
                        name: 'scale-line',
                        dash: [10, 5]
                    });
                    layer.add(line);
                    
                    const midX = (APP_STATE.scaleLine.start.x + APP_STATE.scaleLine.end.x) / 2;
                    const midY = (APP_STATE.scaleLine.start.y + APP_STATE.scaleLine.end.y) / 2;
                    const label = new Konva.Text({
                        x: midX - 30,
                        y: midY - 20,
                        text: pixels.toFixed(1) + ' px',
                        fontSize: 16,
                        fill: '#fff',
                        background: '#ef4444',
                        padding: 5,
                        name: 'scale-line'
                    });
                    layer.add(label);
                    layer.batchDraw();
                    
                    document.getElementById('scale-pixels').textContent = pixels.toFixed(1);
                    document.getElementById('scale-status').textContent = 'Ready! Enter actual distance below';
                    document.getElementById('apply-scale-btn').disabled = false;
                    document.getElementById('scale-modal').classList.add('active');
                    updateStatus('Enter the actual distance in feet');
                }
                return;
            }
        }
        
        function finishWall(isClosed = false) {
            // Clean up all indicators
            if (startPointIndicator) {
                startPointIndicator.destroy();
                startPointIndicator = null;
            }
            if (activeSnapIndicator) {
                activeSnapIndicator.destroy();
                activeSnapIndicator = null;
            }
            
            if (currentWall && currentWall.points.length >= 4) {
                APP_STATE.walls.push(currentWall);
                renderWall(currentWall, false);
                saveUndoState('addWall', currentWall);
                
                // ALWAYS call detectRooms after adding a wall
                detectRooms();
                
                scheduleHeatmapUpdate();
                updateStats();
                
                if (isClosed) {
                    showWallMaterialModal(currentWall);
                    updateStatus('Room created! Select wall material.');
                } else {
                    updateStatus('Wall completed - press Ctrl+Z to undo');
                }
            }
            currentWall = null;
            layer.batchDraw();
        }
        
        function renderWall(wall, isTemporary = false) {
            if (isTemporary) {
                const temp = layer.findOne('.temp-wall');
                if (temp) temp.destroy();
            }
            
            const line = new Konva.Line({
                points: wall.points,
                stroke: '#ef4444',
                strokeWidth: 7,
                lineCap: 'round',
                lineJoin: 'round',
                id: wall.id,
                name: isTemporary ? 'temp-wall' : 'wall'
            });
            
            // Make walls selectable
            if (!isTemporary) {
                makeWallEditable(wall, line);
                
                line.on('contextmenu', (e) => {
                    e.evt.preventDefault();
                    if (confirm('Delete this wall?')) {
                        const index = APP_STATE.walls.indexOf(wall);
                        if (index > -1) {
                            APP_STATE.walls.splice(index, 1);
                        }
                        line.destroy();
                        layer.batchDraw();
                        updateHeatmap();
                        updateStats();
                    }
                });
            }
            
            layer.add(line);
            layer.batchDraw();
        }

        function makeWallEditable(wall, line) {
            // Add click handler to select wall - ONLY when select tool is active
            line.on('click tap', (e) => {
                // Only allow editing when select tool is active
                if (APP_STATE.currentTool !== 'select') {
                    return;
                }
                
                e.cancelBubble = true;
                selectObject(wall, 'wall');
                showWallEditPoints(wall, line);
            });
            
            line.on('contextmenu', (e) => {
                e.evt.preventDefault();
                e.cancelBubble = true;
                if (confirm('Delete this wall?')) {
                    const index = APP_STATE.walls.indexOf(wall);
                    if (index > -1) {
                        APP_STATE.walls.splice(index, 1);
                    }
                    line.destroy();
                    layer.find('.wall-edit-point').forEach(p => p.destroy());
                    layer.batchDraw();
                    detectRooms();
                    updateHeatmap();
                    updateStats();
                }
            });
        }

        function showWallEditPoints(wall, line) {
            // Remove old edit points
            layer.find('.wall-edit-point').forEach(p => p.destroy());
            
            // Add draggable circles at each point
            for (let i = 0; i < wall.points.length; i += 2) {
                const circle = new Konva.Circle({
                    x: wall.points[i],
                    y: wall.points[i + 1],
                    radius: 8,
                    fill: '#f59e0b',
                    stroke: '#fff',
                    strokeWidth: 2,
                    draggable: true,
                    name: 'wall-edit-point'
                });
                
                circle.on('dragmove', () => {
                    wall.points[i] = circle.x();
                    wall.points[i + 1] = circle.y();
                    line.points(wall.points);
                    layer.batchDraw();
                });
                
                circle.on('dragend', () => {
                    detectRooms();
                    updateHeatmap();
                });
                
                layer.add(circle);
            }
            
            layer.batchDraw();
        }

    // Track if showing start point indicator
        let startPointIndicator = null;
        let activeSnapIndicator = null;
        
        function updateWallDrawingVisuals(mousePos) {
            // Only show when actively drawing a wall
            if (!currentWall || currentWall.points.length < 4) {
                if (startPointIndicator) {
                    startPointIndicator.destroy();
                    startPointIndicator = null;
                }
                if (activeSnapIndicator) {
                    activeSnapIndicator.destroy();
                    activeSnapIndicator = null;
                    layer.batchDraw();
                }
                return;
            }
            
            const startX = currentWall.points[0];
            const startY = currentWall.points[1];
            
            // Calculate distance to start point
            const distToStart = Math.sqrt(
                Math.pow(mousePos.x - startX, 2) + 
                Math.pow(mousePos.y - startY, 2)
            );
            
            // Check distance to ANY existing wall (not in current wall)
            let closestWallPoint = null;
            let minWallDist = Infinity;
            const snapDist = APP_STATE.wallSnapDistance;
            
            for (let wall of APP_STATE.walls) {
                const points = wall.points;
                
                // Check each line segment
                for (let i = 0; i < points.length - 2; i += 2) {
                    const x1 = points[i];
                    const y1 = points[i + 1];
                    const x2 = points[i + 2];
                    const y2 = points[i + 3];
                    
                    const closest = closestPointOnLineSegment(mousePos.x, mousePos.y, x1, y1, x2, y2);
                    const dist = Math.sqrt(
                        Math.pow(mousePos.x - closest.x, 2) + 
                        Math.pow(mousePos.y - closest.y, 2)
                    );
                    
                    if (dist < snapDist && dist < minWallDist) {
                        minWallDist = dist;
                        closestWallPoint = { x: closest.x, y: closest.y };
                    }
                }
            }
            
            // Show indicator for existing walls (higher priority)
            if (closestWallPoint && minWallDist < distToStart) {
                // Remove old indicators
                if (startPointIndicator) {
                    startPointIndicator.destroy();
                    startPointIndicator = null;
                }
                if (activeSnapIndicator) {
                    activeSnapIndicator.destroy();
                }
                
                // Create snap to existing wall indicator
                activeSnapIndicator = new Konva.Group({
                    name: 'active-snap-indicator'
                });
                
                // Outer glow circle
                const outerCircle = new Konva.Circle({
                    x: closestWallPoint.x,
                    y: closestWallPoint.y,
                    radius: 18,
                    fill: '#10b981',
                    opacity: 0.3
                });
                
                // Inner circle
                const innerCircle = new Konva.Circle({
                    x: closestWallPoint.x,
                    y: closestWallPoint.y,
                    radius: 10,
                    fill: '#10b981',
                    stroke: '#fff',
                    strokeWidth: 3
                });
                
                // Connection line preview
                const lastX = currentWall.points[currentWall.points.length - 2];
                const lastY = currentWall.points[currentWall.points.length - 1];
                
                const previewLine = new Konva.Line({
                    points: [lastX, lastY, closestWallPoint.x, closestWallPoint.y],
                    stroke: '#10b981',
                    strokeWidth: 3,
                    dash: [8, 4],
                    opacity: 0.7
                });
                
                activeSnapIndicator.add(previewLine);
                activeSnapIndicator.add(outerCircle);
                activeSnapIndicator.add(innerCircle);
                
                layer.add(activeSnapIndicator);
                layer.batchDraw();
                
                updateStatus('Click to connect to wall and complete room');
            }
            // Show indicator for closing back to start (lower priority)
            else if (distToStart < 30) {
                // Remove old indicators
                if (activeSnapIndicator) {
                    activeSnapIndicator.destroy();
                    activeSnapIndicator = null;
                }
                if (startPointIndicator) {
                    startPointIndicator.destroy();
                }
                
                // Create start point indicator
                startPointIndicator = new Konva.Group({
                    name: 'start-indicator'
                });
                
                // Outer glow circle
                const outerCircle = new Konva.Circle({
                    x: startX,
                    y: startY,
                    radius: 18,
                    fill: '#f59e0b',
                    opacity: 0.3
                });
                
                // Inner circle
                const innerCircle = new Konva.Circle({
                    x: startX,
                    y: startY,
                    radius: 10,
                    fill: '#f59e0b',
                    stroke: '#fff',
                    strokeWidth: 3
                });
                
                // Connection line preview
                const lastX = currentWall.points[currentWall.points.length - 2];
                const lastY = currentWall.points[currentWall.points.length - 1];
                
                const previewLine = new Konva.Line({
                    points: [lastX, lastY, startX, startY],
                    stroke: '#f59e0b',
                    strokeWidth: 3,
                    dash: [8, 4],
                    opacity: 0.7
                });
                
                startPointIndicator.add(previewLine);
                startPointIndicator.add(outerCircle);
                startPointIndicator.add(innerCircle);
                
                layer.add(startPointIndicator);
                layer.batchDraw();
                
                updateStatus('Click near start point to close wall');
            } else {
                // Remove indicators when not close to anything
                if (startPointIndicator) {
                    startPointIndicator.destroy();
                    startPointIndicator = null;
                }
                if (activeSnapIndicator) {
                    activeSnapIndicator.destroy();
                    activeSnapIndicator = null;
                }
                layer.batchDraw();
                updateStatus(`Wall: ${currentWall.points.length / 2} points. Ctrl+Z to remove last. Double-click to finish.`);
            }
        }
        
        // Snap to existing walls (endpoints AND line segments)
        function snapToWallEndpoint(pos) {
            const snapDist = APP_STATE.wallSnapDistance;
            let closestPoint = null;
            let minDist = Infinity;
            
            // Check all existing walls
            for (let wall of APP_STATE.walls) {
                const points = wall.points;
                
                // Check each line segment of the wall
                for (let i = 0; i < points.length - 2; i += 2) {
                    const x1 = points[i];
                    const y1 = points[i + 1];
                    const x2 = points[i + 2];
                    const y2 = points[i + 3];
                    
                    // Find closest point on this line segment to mouse position
                    const closest = closestPointOnLineSegment(pos.x, pos.y, x1, y1, x2, y2);
                    const dist = Math.sqrt(
                        Math.pow(pos.x - closest.x, 2) + 
                        Math.pow(pos.y - closest.y, 2)
                    );
                    
                    if (dist < snapDist && dist < minDist) {
                        minDist = dist;
                        closestPoint = { x: closest.x, y: closest.y };
                    }
                }
            }
            
            if (closestPoint) {
                return { x: closestPoint.x, y: closestPoint.y, snapped: true };
            }
            
            return { x: pos.x, y: pos.y, snapped: false };
        }
        
        // Helper function to find closest point on a line segment
        function closestPointOnLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            if (dx === 0 && dy === 0) {
                return { x: x1, y: y1 };
            }
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)));
            
            return {
                x: x1 + t * dx,
                y: y1 + t * dy
            };
        }

        // ===================================================================
        // IMPROVED ROOM DETECTION - PERIMETER-FIRST APPROACH
        // ===================================================================
        function detectRooms() {
            console.log('=== DETECTING ROOMS (Perimeter-First) ===');
            APP_STATE.rooms = [];
            APP_STATE.buildingArea = 0; // Reset building area
            
            if (APP_STATE.walls.length === 0) {
                console.log('No walls present');
                updateRoomsPanel();
                return;
            }
            
            console.log('Total walls:', APP_STATE.walls.length);
            
            // Step 1: Find the building perimeter (outermost boundary)
            const perimeter = findBuildingPerimeter();
            
            if (!perimeter) {
                console.log('No building perimeter detected');
                updateRoomsPanel();
                return;
            }
            
            // STORE THE BUILDING AREA
            APP_STATE.buildingArea = perimeter.area;
            
            console.log('Building perimeter found with', perimeter.points.length / 2, 'points');
            console.log('Building area:', APP_STATE.buildingArea.toFixed(2), 'sq ft');
            
            // Step 2: Use grid-based flood fill to find all rooms
            const rooms = findRoomsUsingFloodFill(perimeter);
            
            console.log('Found', rooms.length, 'rooms');
            
            // Step 3: Create room objects (INTERIOR ROOMS ONLY)
            rooms.forEach((roomData, index) => {
                const area = roomData.area;
                
                const room = {
                    id: 'room_' + Date.now() + '_' + index,
                    wallId: 'multi',
                    name: `Room ${APP_STATE.rooms.length + 1}`,
                    material: 8,
                    points: roomData.points,
                    area: area,
                    centroid: roomData.centroid,
                    type: 'interior'
                };
                
                APP_STATE.rooms.push(room);
                console.log(`Room ${room.name}: ${area.toFixed(1)} sq ft`);
            });
            
            console.log('Total rooms detected:', APP_STATE.rooms.length);
            console.log('Total building area:', APP_STATE.buildingArea.toFixed(2), 'sq ft');
            updateRoomsPanel();
        }

        function findBuildingPerimeter() {
            // Find all closed walls first
            const closedWalls = [];
            
            APP_STATE.walls.forEach(wall => {
                if (wall.points.length < 6) return;
                
                const firstX = wall.points[0];
                const firstY = wall.points[1];
                const lastX = wall.points[wall.points.length - 2];
                const lastY = wall.points[wall.points.length - 1];
                
                const dist = Math.sqrt(Math.pow(firstX - lastX, 2) + Math.pow(firstY - lastY, 2));
                
                if (dist < 20) {
                    const area = calculatePolygonArea(wall.points);
                    closedWalls.push({ wall, area, points: wall.points });
                }
            });
            
            // The perimeter is the largest closed polygon
            if (closedWalls.length > 0) {
                closedWalls.sort((a, b) => b.area - a.area);
                console.log('Found', closedWalls.length, 'closed walls');
                console.log('Largest area:', closedWalls[0].area.toFixed(2));
                return closedWalls[0];
            }
            
            // If no closed wall, try to find the convex hull of all wall endpoints
            const allPoints = [];
            APP_STATE.walls.forEach(wall => {
                for (let i = 0; i < wall.points.length; i += 2) {
                    allPoints.push({ x: wall.points[i], y: wall.points[i + 1] });
                }
            });
            
            if (allPoints.length > 0) {
                const hull = convexHull(allPoints);
                const hullPoints = [];
                hull.forEach(p => {
                    hullPoints.push(p.x, p.y);
                });
                
                return {
                    points: hullPoints,
                    area: calculatePolygonArea(hullPoints)
                };
            }
            
            return null;
        }

        function findRoomsUsingFloodFill(perimeter) {
            // Get bounds of the perimeter
            const bounds = getBounds(perimeter.points);
            
            // Create a grid resolution (in pixels)
            const gridSize = 10; // 10 pixels per grid cell
            const gridWidth = Math.ceil((bounds.maxX - bounds.minX) / gridSize);
            const gridHeight = Math.ceil((bounds.maxY - bounds.minY) / gridSize);
            
            console.log(`Creating grid: ${gridWidth}x${gridHeight} (${gridWidth * gridHeight} cells)`);
            
            // Create grid (0 = unvisited, -1 = wall, positive = room ID)
            const grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
            
            // Mark walls in the grid
            APP_STATE.walls.forEach(wall => {
                markWallInGrid(grid, wall.points, bounds, gridSize);
            });
            
            // Flood fill from multiple seed points to find all rooms
            const rooms = [];
            let roomId = 1;
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    // If cell is unvisited (0) and inside perimeter
                    if (grid[y][x] === 0) {
                        const worldX = bounds.minX + x * gridSize + gridSize / 2;
                        const worldY = bounds.minY + y * gridSize + gridSize / 2;
                        
                        // Check if point is inside perimeter
                        if (isPointInPolygon(worldX, worldY, perimeter.points)) {
                            // Found a new room! Flood fill it
                            const roomCells = floodFill(grid, x, y, roomId);
                            
                            if (roomCells.length > 4) { // Minimum room size (4 cells)
                                const roomPolygon = cellsToPolygon(roomCells, bounds, gridSize);
                                const area = (roomCells.length * gridSize * gridSize) * (APP_STATE.scale * APP_STATE.scale);
                                
                                rooms.push({
                                    id: roomId,
                                    points: roomPolygon,
                                    area: area,
                                    centroid: getCentroid(roomPolygon)
                                });
                                
                                roomId++;
                            }
                        }
                    }
                }
            }
            
            return rooms;
        }

        function markWallInGrid(grid, wallPoints, bounds, gridSize) {
            // Mark all cells that the wall passes through
            for (let i = 0; i < wallPoints.length - 2; i += 2) {
                const x1 = wallPoints[i];
                const y1 = wallPoints[i + 1];
                const x2 = wallPoints[i + 2];
                const y2 = wallPoints[i + 3];
                
                // Use Bresenham's line algorithm to mark all cells along the wall
                bresenhamLine(x1, y1, x2, y2, (x, y) => {
                    const gridX = Math.floor((x - bounds.minX) / gridSize);
                    const gridY = Math.floor((y - bounds.minY) / gridSize);
                    
                    if (gridX >= 0 && gridX < grid[0].length && gridY >= 0 && gridY < grid.length) {
                        grid[gridY][gridX] = -1; // Mark as wall
                    }
                });
            }
        }

        function bresenhamLine(x1, y1, x2, y2, callback) {
            x1 = Math.round(x1);
            y1 = Math.round(y1);
            x2 = Math.round(x2);
            y2 = Math.round(y2);
            
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;
            
            let steps = 0;
            const maxSteps = 10000; // Prevent infinite loops
            
            while (steps < maxSteps) {
                callback(x1, y1);
                
                if (x1 === x2 && y1 === y2) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x1 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y1 += sy;
                }
                
                steps++;
            }
        }

        function floodFill(grid, startX, startY, roomId) {
            const cells = [];
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                if (x < 0 || x >= grid[0].length || y < 0 || y >= grid.length) continue;
                if (grid[y][x] !== 0) continue; // Already visited or wall
                
                visited.add(key);
                grid[y][x] = roomId;
                cells.push([x, y]);
                
                // Add 4-connected neighbors
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
            
            return cells;
        }

        function cellsToPolygon(cells, bounds, gridSize) {
            // Find the boundary of the room cells
            // For simplicity, create a bounding box around the cells
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            cells.forEach(([x, y]) => {
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            });
            
            // Convert grid coordinates to world coordinates
            const worldMinX = bounds.minX + minX * gridSize;
            const worldMinY = bounds.minY + minY * gridSize;
            const worldMaxX = bounds.minX + (maxX + 1) * gridSize;
            const worldMaxY = bounds.minY + (maxY + 1) * gridSize;
            
            // Return rectangle points
            return [
                worldMinX, worldMinY,
                worldMaxX, worldMinY,
                worldMaxX, worldMaxY,
                worldMinX, worldMaxY
            ];
        }

        function getBounds(points) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            for (let i = 0; i < points.length; i += 2) {
                minX = Math.min(minX, points[i]);
                maxX = Math.max(maxX, points[i]);
                minY = Math.min(minY, points[i + 1]);
                maxY = Math.max(maxY, points[i + 1]);
            }
            
            return { minX, minY, maxX, maxY };
        }

        function getCentroid(points) {
            let x = 0, y = 0;
            const n = points.length / 2;
            
            for (let i = 0; i < points.length; i += 2) {
                x += points[i];
                y += points[i + 1];
            }
            
            return { x: x / n, y: y / n };
        }

        function convexHull(points) {
            // Graham scan algorithm for convex hull
            if (points.length < 3) return points;
            
            // Find the point with lowest y-coordinate (and leftmost if tie)
            let start = points[0];
            for (let i = 1; i < points.length; i++) {
                if (points[i].y < start.y || (points[i].y === start.y && points[i].x < start.x)) {
                    start = points[i];
                }
            }
            
            // Sort points by polar angle with respect to start point
            const sorted = points.slice().sort((a, b) => {
                const angleA = Math.atan2(a.y - start.y, a.x - start.x);
                const angleB = Math.atan2(b.y - start.y, b.x - start.x);
                if (angleA !== angleB) return angleA - angleB;
                // If same angle, closer point first
                const distA = Math.pow(a.x - start.x, 2) + Math.pow(a.y - start.y, 2);
                const distB = Math.pow(b.x - start.x, 2) + Math.pow(b.y - start.y, 2);
                return distA - distB;
            });
            
            const hull = [sorted[0], sorted[1]];
            
            for (let i = 2; i < sorted.length; i++) {
                while (hull.length >= 2) {
                    const cross = crossProduct(hull[hull.length - 2], hull[hull.length - 1], sorted[i]);
                    if (cross > 0) break;
                    hull.pop();
                }
                hull.push(sorted[i]);
            }
            
            return hull;
        }

        function crossProduct(o, a, b) {
            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        }
        
        let pendingWallForMaterial = null;
        
        function showWallMaterialModal(wall) {
            pendingWallForMaterial = wall;
            document.getElementById('new-wall-material').value = wall.attenuation;
            document.getElementById('wall-material-modal').classList.add('active');
        }
        
        function applyWallMaterial() {
            if (!pendingWallForMaterial) return;
            
            const material = parseInt(document.getElementById('new-wall-material').value);
            pendingWallForMaterial.attenuation = material;
            
            console.log('Applied material:', material, 'dB to wall:', pendingWallForMaterial.id);
            
            document.getElementById('wall-material-modal').classList.remove('active');
            pendingWallForMaterial = null;
            
            updateHeatmap();
            detectRooms(); // Redetect rooms with updated material
            updateStatus('Wall material applied');
        }

        // Calculate area of polygon
        function calculatePolygonArea(points) {
            let area = 0;
            const n = points.length / 2;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                const xi = points[i * 2];
                const yi = points[i * 2 + 1];
                const xj = points[j * 2];
                const yj = points[j * 2 + 1];
                
                area += xi * yj - xj * yi;
            }
            
            area = Math.abs(area / 2);
            
            // Convert to square feet
            const sqFeet = area * (APP_STATE.scale * APP_STATE.scale);
            return sqFeet;
        }
        
        function updateRoomsPanel() {
            const roomsList = document.getElementById('rooms-list');
            
            if (!roomsList) {
                console.error('Rooms list element not found!');
                return;
            }
            
            if (APP_STATE.rooms.length === 0) {
                roomsList.innerHTML = '<p style="color: var(--text-secondary);">No rooms detected. Draw closed walls to create rooms.</p>';
            } else {
                roomsList.innerHTML = '';
                
                // Header
                const header = document.createElement('div');
                header.style.cssText = 'margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); color: var(--text-primary); font-size: 14px;';
                header.innerHTML = `<strong>${APP_STATE.rooms.length} Interior Rooms</strong><br><span style="font-size: 12px; color: var(--text-secondary);">Building: ${APP_STATE.buildingArea.toFixed(1)} sq ft</span>`;
                roomsList.appendChild(header);
                
                APP_STATE.rooms.forEach((room, index) => {
                    const roomDiv = document.createElement('div');
                    roomDiv.style.cssText = 'background: var(--bg-secondary); padding: 10px; margin-bottom: 8px; border-radius: 6px; border: 2px solid var(--border-color); transition: all 0.2s;';
                    
                    // Editable room name
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = room.name;
                    nameInput.style.cssText = 'background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; color: var(--text-primary); font-size: 14px; font-weight: 600; width: 100%; margin-bottom: 8px;';
                    
                    nameInput.addEventListener('change', (e) => {
                        room.name = e.target.value;
                        renderRoomLabels();
                        updateStatus(`Room renamed to "${room.name}"`);
                    });
                    
                    const details = document.createElement('div');
                    details.innerHTML = `
                        <div style="font-size: 12px; color: var(--text-secondary);">Area: ${room.area.toFixed(1)} sq ft</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">Material: ${getMaterialName(room.material)}</div>
                    `;
                    
                    roomDiv.appendChild(nameInput);
                    roomDiv.appendChild(details);
                    
                    roomDiv.addEventListener('mouseenter', () => {
                        roomDiv.style.borderColor = 'var(--primary-color)';
                        roomDiv.style.background = 'var(--bg-tertiary)';
                        highlightRoom(room);
                    });
                    
                    roomDiv.addEventListener('mouseleave', () => {
                        roomDiv.style.borderColor = 'var(--border-color)';
                        roomDiv.style.background = 'var(--bg-secondary)';
                        layer.find('.room-highlight').forEach(h => h.destroy());
                        layer.batchDraw();
                    });
                    
                    roomsList.appendChild(roomDiv);
                });
            }
            
            updateStats();
            renderRoomLabels();
            feather.replace();
        }
        
        function renderRoomLabels() {
            // Remove old labels
            layer.find('.room-label').forEach(l => l.destroy());
            
            APP_STATE.rooms.forEach(room => {
                if (!room.centroid) return;
                
                // Create label background
                const labelBg = new Konva.Rect({
                    x: room.centroid.x - 40,
                    y: room.centroid.y - 15,
                    width: 80,
                    height: 30,
                    fill: '#3b82f6',
                    opacity: 0.8,
                    cornerRadius: 4,
                    name: 'room-label'
                });
                
                // Create label text
                const labelText = new Konva.Text({
                    x: room.centroid.x - 40,
                    y: room.centroid.y - 10,
                    width: 80,
                    text: room.name,
                    fontSize: 14,
                    fontStyle: 'bold',
                    fill: '#fff',
                    align: 'center',
                    name: 'room-label'
                });
                
                layer.add(labelBg);
                layer.add(labelText);
            });
            
            layer.batchDraw();
        }

        // Highlight a room briefly
        function highlightRoom(room) {
            const highlight = new Konva.Line({
                points: room.points,
                stroke: '#3b82f6',
                strokeWidth: 8,
                opacity: 0.6,
                lineCap: 'round',
                lineJoin: 'round',
                name: 'room-highlight'
            });
            
            layer.add(highlight);
            layer.batchDraw();
            
            // Fade out after 2 seconds
            setTimeout(() => {
                highlight.destroy();
                layer.batchDraw();
            }, 2000);
        }
        
        function getMaterialName(attenuation) {
            const materials = {
                3: 'Glass',
                5: 'Wood',
                8: 'Drywall',
                12: 'Concrete',
                15: 'Brick',
                20: 'Metal'
            };
            return materials[attenuation] || `${attenuation} dB`;
        }

        function updateSelectedWall() {
            if (!APP_STATE.selectedObject || APP_STATE.selectedObject.type !== 'wall') return;
            
            const wall = APP_STATE.selectedObject.object;
            wall.attenuation = parseInt(document.getElementById('wall-material').value);
            
            updateHeatmap();
            updateStatus('Wall material updated');
        }
        
        function deleteWall() {
            if (!APP_STATE.selectedObject || APP_STATE.selectedObject.type !== 'wall') return;
            
            const wall = APP_STATE.selectedObject.object;
            const index = APP_STATE.walls.indexOf(wall);
            if (index > -1) {
                APP_STATE.walls.splice(index, 1);
            }
            
            const line = layer.findOne('#' + wall.id);
            if (line) {
                line.destroy();
                layer.batchDraw();
            }
            
            APP_STATE.selectedObject = null;
            updateUI();
            updateHeatmap();
            updateStats();
        }

// ===================================================================
        // OBSTACLE DRAWING
        // ===================================================================
        let obstacleStart = null;
        
        function addObstacle(x, y) {
            if (!obstacleStart) {
                obstacleStart = { x, y };
                updateStatus('Click again to set obstacle size');
            } else {
                const id = 'obstacle_' + Date.now();
                const obstacle = {
                    id: id,
                    x: Math.min(obstacleStart.x, x),
                    y: Math.min(obstacleStart.y, y),
                    width: Math.abs(x - obstacleStart.x),
                    height: Math.abs(y - obstacleStart.y),
                    attenuation: 5 // dB
                };
                
                APP_STATE.obstacles.push(obstacle);
                renderObstacle(obstacle);
                saveUndoState('addObstacle', obstacle);
                obstacleStart = null;
                scheduleHeatmapUpdate();
                updateStats();
            }
        }
        
        function renderObstacle(obstacle) {
            const rect = new Konva.Rect({
                x: obstacle.x,
                y: obstacle.y,
                width: obstacle.width,
                height: obstacle.height,
                fill: '#8b5cf6',
                opacity: 0.3,
                stroke: '#6d28d9',
                strokeWidth: 2,
                id: obstacle.id,
                draggable: true
            });
            
            rect.on('dragmove', () => {
                obstacle.x = rect.x();
                obstacle.y = rect.y();
                scheduleHeatmapUpdate();
            });
            
            rect.on('click tap', () => {
                selectObject(obstacle, 'obstacle');
            });
            
            layer.add(rect);
            layer.batchDraw();
        }        

        // ===================================================================
        // CLIENT SIMULATION
        // ===================================================================
        function simulateClients() {
            if (APP_STATE.accessPoints.length === 0) {
                alert('Please add access points first');
                return;
            }
            
            clearClients();
            
            const count = parseInt(document.getElementById('client-count').value);
            const width = APP_STATE.floorPlan ? APP_STATE.floorPlan.width : stage.width();
            const height = APP_STATE.floorPlan ? APP_STATE.floorPlan.height : stage.height();
            
            showLoading(true);
            
            let placedClients = 0;
            let attempts = 0;
            const maxAttempts = count * 10; // Try up to 10x the number of clients
            
            // Generate random client positions INSIDE rooms
            while (placedClients < count && attempts < maxAttempts) {
                attempts++;
                
                const x = Math.random() * width;
                const y = Math.random() * height;
                
                // Check if point is inside any room
                let insideRoom = false;
                
                if (APP_STATE.rooms.length > 0) {
                    for (let room of APP_STATE.rooms) {
                        if (isPointInPolygon(x, y, room.points)) {
                            insideRoom = true;
                            break;
                        }
                    }
                } else {
                    // If no rooms defined, place anywhere
                    insideRoom = true;
                }
                
                if (!insideRoom) continue;
                
                // Find strongest AP for this client
                let bestAP = null;
                let bestRSSI = -Infinity;
                
                APP_STATE.accessPoints.forEach(ap => {
                    const rssi = calculateRSSI(ap, x, y, '5');
                    if (rssi > bestRSSI) {
                        bestRSSI = rssi;
                        bestAP = ap;
                    }
                });
                
                const client = {
                    id: 'client_' + placedClients,
                    x: x,
                    y: y,
                    connectedAP: bestAP ? bestAP.id : null,
                    rssi: bestRSSI
                };
                
                APP_STATE.clients.push(client);
                renderClient(client);
                placedClients++;
            }
            
            showLoading(false);
            
            if (placedClients < count) {
                updateStatus(`Placed ${placedClients} of ${count} clients inside rooms`);
            } else {
                updateStatus(`${count} clients simulated inside rooms`);
            }
            
            updateStats();
            updateDensityHeatmap();
        }
        
        // Check if a point is inside a polygon (ray casting algorithm)
        function isPointInPolygon(x, y, points) {
            let inside = false;
            const n = points.length / 2;
            
            for (let i = 0, j = n - 1; i < n; j = i++) {
                const xi = points[i * 2];
                const yi = points[i * 2 + 1];
                const xj = points[j * 2];
                const yj = points[j * 2 + 1];
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        function renderClient(client) {
            const ap = APP_STATE.accessPoints.find(a => a.id === client.connectedAP);
            const color = ap ? '#1a4503' : '#e61212';
            
            // Create group for client
            const clientGroup = new Konva.Group({
                id: client.id,
                name: 'client-group'
            });
            
            // Draw line to connected AP (will be updated by updateClientLines)
            if (ap) {
                const line = new Konva.Line({
                    points: [client.x, client.y, ap.x, ap.y],
                    stroke: color,
                    strokeWidth: 2,
                    opacity: 0.5,
                    dash: [8, 4],
                    name: 'client-line',
                    listening: false
                });
                clientGroup.add(line);
            }
            
            // Draw the client circle
            const circle = new Konva.Circle({
                x: client.x,
                y: client.y,
                radius: 6,
                fill: color,
                opacity: 0.9,
                stroke: '#fff',
                strokeWidth: 1,
                name: 'client-circle'
            });
            clientGroup.add(circle);
            
            // Add hover tooltip
            clientGroup.on('mouseenter', () => {
                const speeds = estimateClientSpeed(client);
                const tooltip = document.getElementById('signal-tooltip');
                const list = document.getElementById('signal-list');
                
                list.innerHTML = `
                    <div class="signal-item">
                        <span>RSSI:</span>
                        <span>${speeds.rssi.toFixed(1)} dBm</span>
                    </div>
                    <div class="signal-item">
                        <span>WiFi Speed:</span>
                        <span>${speeds.wifiSpeed} Mbps</span>
                    </div>
                    <div class="signal-item signal-strong">
                        <span>Download:</span>
                        <span>${speeds.download} Mbps</span>
                    </div>
                    <div class="signal-item signal-strong">
                        <span>Upload:</span>
                        <span>${speeds.upload} Mbps</span>
                    </div>
                `;
                
                const pos = stage.getPointerPosition();
                if (pos) {
                    tooltip.style.left = (pos.x + 20) + 'px';
                    tooltip.style.top = (pos.y + 20) + 'px';
                    tooltip.classList.add('active');
                }
            });
            
            clientGroup.on('mouseleave', () => {
                document.getElementById('signal-tooltip').classList.remove('active');
            });
            
            // Click to remove
            clientGroup.on('click tap', (e) => {
                e.cancelBubble = true;
                if (confirm('Remove this client?')) {
                    const index = APP_STATE.clients.findIndex(c => c.id === client.id);
                    if (index > -1) {
                        APP_STATE.clients.splice(index, 1);
                    }
                    clientGroup.destroy();
                    layer.batchDraw();
                    updateStats();
                    updateDensityHeatmap();
                    updateStatus('Client removed');
                }
            });
            
            clientGroup.on('mouseenter', () => {
                document.getElementById('konva-container').style.cursor = 'pointer';
            });
            
            clientGroup.on('mouseleave', () => {
                if (APP_STATE.currentTool === 'select') {
                    document.getElementById('konva-container').style.cursor = 'default';
                }
            });
            
            layer.add(clientGroup);
            layer.batchDraw();
        }
        
        function addSingleClient(x, y) {
            // Find strongest AP for this client
            let bestAP = null;
            let bestRSSI = -Infinity;
            
            APP_STATE.accessPoints.forEach(ap => {
                const rssi = calculateRSSI(ap, x, y, '5');
                if (rssi > bestRSSI) {
                    bestRSSI = rssi;
                    bestAP = ap;
                }
            });
            
            const client = {
                id: 'client_' + Date.now(),
                x: x,
                y: y,
                connectedAP: bestAP ? bestAP.id : null,
                rssi: bestRSSI
            };
            
            APP_STATE.clients.push(client);
            renderClient(client);
            updateStats();
            updateDensityHeatmap();
            updateStatus('Client placed');
        }

        function clearClients() {
            APP_STATE.clients.forEach(client => {
                const group = layer.findOne('#' + client.id);
                if (group) group.destroy();
            });
            
            layer.find('.client-group').forEach(g => g.destroy());
            layer.find('.client-line').forEach(l => l.destroy());
            layer.find('.client-circle').forEach(c => c.destroy());
            
            APP_STATE.clients = [];
            layer.batchDraw();
            
            // Clear density heatmap
            updateDensityHeatmap();
            
            updateStats();
        }
        
        // ===================================================================
        // RF PROPAGATION & HEATMAP
        // ===================================================================
        function scheduleHeatmapUpdate() {
            if (heatmapUpdateTimer) {
                clearTimeout(heatmapUpdateTimer);
            }
            heatmapUpdateTimer = setTimeout(updateHeatmap, 100);
        }
        
        function updateHeatmap() {
            if (!APP_STATE.heatmapEnabled || APP_STATE.accessPoints.length === 0) {
                heatmapLayer.destroyChildren();
                heatmapLayer.batchDraw();
                return;
            }
            
            showLoading(true);
            
            // Use requestAnimationFrame for non-blocking update
            requestAnimationFrame(() => {
                generateHeatmap();
                showLoading(false);
            });
        }
        
        function generateHeatmap() {
            heatmapLayer.destroyChildren();
            
            const width = APP_STATE.floorPlan ? APP_STATE.floorPlan.width : stage.width();
            const height = APP_STATE.floorPlan ? APP_STATE.floorPlan.height : stage.height();
            
            // Resolution settings
            let step = 20; // pixels
            if (APP_STATE.heatmapResolution === 'low') step = 40;
            if (APP_STATE.heatmapResolution === 'high') step = 10;
            
            const canvas = document.createElement('canvas');
            canvas.width = Math.ceil(width / step);
            canvas.height = Math.ceil(height / step);
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            let coverageCount = 0;
            let totalPoints = 0;
            
            // Calculate signal strength for each grid point
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const worldX = x * step;
                    const worldY = y * step;
                    
                    // Find strongest signal at this point
                    let maxRSSI = -Infinity;
                    
                    APP_STATE.accessPoints.forEach(ap => {
                        const rssi = calculateRSSI(ap, worldX, worldY, '5');
                        maxRSSI = Math.max(maxRSSI, rssi);
                    });
                    
                    // Count coverage
                    totalPoints++;
                    if (maxRSSI > -65) coverageCount++;
                    
                    // Convert RSSI to color
                    const color = rssiToColor(maxRSSI);
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = color.r;
                    data[idx + 1] = color.g;
                    data[idx + 2] = color.b;
                    data[idx + 3] = color.a;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Update coverage stat
            const coveragePercent = totalPoints > 0 ? ((coverageCount / totalPoints) * 100).toFixed(1) : 0;
            document.getElementById('stat-coverage').textContent = coveragePercent + '%';
            
            // Add to Konva
            const heatmapImage = new Konva.Image({
                image: canvas,
                width: width,
                height: height,
                opacity: APP_STATE.heatmapOpacity
            });
            
            heatmapLayer.add(heatmapImage);
            heatmapLayer.batchDraw();
        }
        
        async function exportHeatmapPNG() {
            if (!APP_STATE.heatmapEnabled || APP_STATE.accessPoints.length === 0) {
                alert('Please enable heatmap and add access points first');
                return;
            }
            
            showLoading(true);
            
            try {
                // Check if saveAs is available
                if (typeof saveAs === 'undefined') {
                    throw new Error('FileSaver library not loaded. Please refresh the page and try again.');
                }
                
                // Capture the canvas
                const canvas = await captureCanvas();
                
                if (!canvas) {
                    throw new Error('Failed to capture canvas');
                }
                
                // Convert to blob and save
                return new Promise((resolve, reject) => {
                    canvas.toBlob((blob) => {
                        if (!blob) {
                            reject(new Error('Failed to create image blob'));
                            return;
                        }
                        
                        try {
                            saveAs(blob, `${APP_STATE.projectName}_Heatmap.png`);
                            updateStatus('Heatmap exported as PNG');
                            showLoading(false);
                            resolve();
                        } catch (saveError) {
                            reject(saveError);
                        }
                    }, 'image/png');
                });
            } catch (error) {
                console.error('Error exporting heatmap:', error);
                alert('Error exporting heatmap: ' + error.message);
                showLoading(false);
            }
        }

        /**
         * Calculate RSSI at a point from an AP
         * Uses Free Space Path Loss + wall attenuation
         */
        function calculateRSSI(ap, x, y, band) {
            const dx = x - ap.x;
            const dy = y - ap.y;
            const distance = Math.sqrt(dx * dx + dy * dy) * APP_STATE.scale; // Convert to feet
        
        if (distance < 0.3) return 0; // Very close (changed from 0.1m to 0.3ft)
            
            // Get TX power for band
            const txPower = band === '2.4' ? ap.config.tx24 : ap.config.tx5;
            
            // Frequency in MHz
            const freq = band === '2.4' ? 2437 : 5180;
            
            // Free Space Path Loss: FSPL(dB) = 20*log10(d) + 20*log10(f) + 20*log10(4/c) - Gt - Gr
            // Simplified: FSPL = 20*log10(freq_MHz) + 20*log10(distance_m) - 27.55
            const fspl = 20 * Math.log10(freq) + 20 * Math.log10(distance) - 27.55;
            
            // Antenna gain
            let antennaGain = ap.device.antenna.gain;
            
            // Apply directional antenna pattern
            if (ap.config.antennaType === 'directional') {
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                const relativeAngle = Math.abs(((angle - ap.config.orientation + 180) % 360) - 180);
                const beamwidth = ap.device.antenna.beamwidth || 60;
                
                if (relativeAngle > beamwidth / 2) {
                    // Outside main lobe
                    const falloff = (relativeAngle - beamwidth / 2) / 90; // Normalize
                    antennaGain -= Math.min(20, falloff * 20); // Up to 20dB reduction
                }
            }
            
            // Count walls crossed
            let wallLoss = 0;
            APP_STATE.walls.forEach(wall => {
                if (lineIntersectsWall(ap.x, ap.y, x, y, wall)) {
                    wallLoss += wall.attenuation;
                }
            });
            
            // Calculate received power
            const rxPower = txPower + antennaGain - fspl - wallLoss;
            
            return rxPower;
        }

        function estimateClientSpeed(client) {
            if (!client.connectedAP) {
                return { download: 0, upload: 0 };
            }
            
            const ap = APP_STATE.accessPoints.find(a => a.id === client.connectedAP);
            if (!ap) return { download: 0, upload: 0 };
            
            const rssi = client.rssi;
            
            // Get internet speeds
            const internetDown = parseFloat(document.getElementById('internet-download')?.value || 1000);
            const internetUp = parseFloat(document.getElementById('internet-upload')?.value || 1000);
            
            // Estimate WiFi speed based on RSSI (802.11ac/ax)
            let wifiSpeed;
            
            if (rssi > -30) {
                wifiSpeed = 1200; // Excellent: 1.2 Gbps
            } else if (rssi > -50) {
                wifiSpeed = 866; // Very good: 866 Mbps
            } else if (rssi > -60) {
                wifiSpeed = 600; // Good: 600 Mbps
            } else if (rssi > -67) {
                wifiSpeed = 400; // Fair: 400 Mbps
            } else if (rssi > -70) {
                wifiSpeed = 200; // Marginal: 200 Mbps
            } else if (rssi > -75) {
                wifiSpeed = 100; // Poor: 100 Mbps
            } else if (rssi > -80) {
                wifiSpeed = 50; // Very poor: 50 Mbps
            } else {
                wifiSpeed = 10; // Barely connected: 10 Mbps
            }
            
            // Bottleneck is the slower of WiFi or Internet
            const actualDown = Math.min(wifiSpeed, internetDown);
            const actualUp = Math.min(wifiSpeed, internetUp);
            
            return {
                download: actualDown,
                upload: actualUp,
                wifiSpeed: wifiSpeed,
                rssi: rssi
            };
        }
        
        function lineIntersectsWall(x1, y1, x2, y2, wall) {
            // Check if line segment intersects any segment of the wall
            const points = wall.points;
            for (let i = 0; i < points.length - 2; i += 2) {
                if (lineSegmentsIntersect(
                    x1, y1, x2, y2,
                    points[i], points[i + 1], points[i + 2], points[i + 3]
                )) {
                    return true;
                }
            }
            return false;
        }
        
        function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            if (denom === 0) return false;
            
            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
            
            return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
        }
        
        function rssiToColor(rssi) {
            // Color scale: red (poor) -> yellow (ok) -> green (good)
            // RSSI ranges: < -80 (poor), -80 to -65 (fair), -65 to -50 (good), > -50 (excellent)
            
            if (rssi < -100) return { r: 0, g: 0, b: 0, a: 0 }; // No signal
            
            let r, g, b, a = 200;
            
            if (rssi > -50) {
                // Excellent: bright green
                r = 0;
                g = 255;
                b = 0;
            } else if (rssi > -65) {
                // Good: green to yellow
                const t = (rssi + 65) / 15;
                r = Math.floor(255 * (1 - t));
                g = 255;
                b = 0;
            } else if (rssi > -80) {
                // Fair: yellow to orange
                const t = (rssi + 80) / 15;
                r = 255;
                g = Math.floor(255 * t);
                b = 0;
            } else {
                // Poor: orange to red
                const t = Math.max(0, (rssi + 100) / 20);
                r = 255;
                g = Math.floor(128 * t);
                b = 0;
            }
            
            return { r, g, b, a };
        }
        
        // ===================================================================
        // SCALE TOOL
        // ===================================================================
        function applyScale() {
            const distance = parseFloat(document.getElementById('scale-distance').value);
            const pixels = parseFloat(document.getElementById('scale-pixels').textContent);
            
            if (!distance || !pixels || distance <= 0 || pixels <= 0) {
                alert('Please complete both steps: click two points and enter distance');
                return;
            }
            
            APP_STATE.scale = distance / pixels;
            document.getElementById('status-right').textContent = `Scale: ${APP_STATE.scale.toFixed(4)} ft/px`;
            
            // Clean up visual aids
            layer.find('.scale-point').forEach(p => p.destroy());
            layer.find('.scale-line').forEach(l => l.destroy());
            layer.batchDraw();
            
            document.getElementById('scale-modal').classList.remove('active');
            document.getElementById('scale-status').textContent = 'Waiting for first point...';
            document.getElementById('scale-pixels').textContent = '0';
            document.getElementById('scale-distance').value = '';
            document.getElementById('apply-scale-btn').disabled = true;
            APP_STATE.scaleLine = null;
            selectTool('select');
            
            updateHeatmap();
            updateStatus('Scale set successfully');
        }
        
        // ===================================================================
        // PROJECT MANAGEMENT
        // ===================================================================
        function newProject() {
            if (confirm('Create new project? Unsaved changes will be lost.')) {
                APP_STATE.projectName = 'Untitled Project';
                APP_STATE.floorPlan = null;
                APP_STATE.accessPoints = [];
                APP_STATE.walls = [];
                APP_STATE.clients = [];
                APP_STATE.selectedObject = null;
                
                layer.destroyChildren();
                heatmapLayer.destroyChildren();
                
                const bgLayer = stage.getLayers()[0];
                bgLayer.destroyChildren();
                
                stage.batchDraw();
                
                document.getElementById('project-name').value = APP_STATE.projectName;
                updateUI();
                updateStats();
            }
        }
        
        function saveProject() {
            const project = {
                name: APP_STATE.projectName,
                version: '1.0',
                scale: APP_STATE.scale,
                floorPlan: APP_STATE.floorPlan ? {
                    dataURL: APP_STATE.floorPlan.dataURL,
                    width: APP_STATE.floorPlan.width,
                    height: APP_STATE.floorPlan.height
                } : null,
                accessPoints: APP_STATE.accessPoints.map(ap => ({
                    x: ap.x,
                    y: ap.y,
                    device: ap.device,
                    config: ap.config,
                    angle: ap.angle
                })),
                walls: APP_STATE.walls,
                obstacles: APP_STATE.obstacles
            };
            
            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            saveAs(blob, `${APP_STATE.projectName}.json`);
            
            updateStatus('Project saved');
        }
        
        function openProject() {
            document.getElementById('project-input').click();
        }
        
        async function handleProjectLoad(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const project = JSON.parse(text);
                
                // Load project
                APP_STATE.projectName = project.name;
                APP_STATE.scale = project.scale;
                
                document.getElementById('project-name').value = project.name;
                document.getElementById('status-right').textContent = `Scale: ${project.scale.toFixed(4)} m/px`;
                
                // Clear current
                layer.destroyChildren();
                heatmapLayer.destroyChildren();
                APP_STATE.accessPoints = [];
                APP_STATE.walls = [];
                APP_STATE.clients = [];
                
                // Load floor plan
                if (project.floorPlan) {
                    const img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = project.floorPlan.dataURL;
                    });
                    
                    APP_STATE.floorPlan = {
                        image: img,
                        width: project.floorPlan.width,
                        height: project.floorPlan.height,
                        dataURL: project.floorPlan.dataURL
                    };
                    
                    renderFloorPlan();
                }
                
                // Load walls
                project.walls.forEach(wall => {
                    APP_STATE.walls.push(wall);
                    renderWall(wall);
                });
                
                // Load APs
                project.accessPoints.forEach(apData => {
                    const ap = {
                        id: 'ap_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        x: apData.x,
                        y: apData.y,
                        device: apData.device,
                        config: apData.config,
                        angle: apData.angle || 0
                    };
                    APP_STATE.accessPoints.push(ap);
                    renderAP(ap);
                });
                
                updateHeatmap();
                updateStats();
                updateStatus('Project loaded');
            } catch (error) {
                console.error('Error loading project:', error);
                alert('Error loading project: ' + error.message);
            }
        }
        
        async function captureCanvas() {
            return new Promise((resolve, reject) => {
                try {
                    // Method 1: Try toDataURL first (most reliable)
                    const dataURL = stage.toDataURL({ pixelRatio: 2 });
                    
                    // Convert data URL to canvas
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(canvas);
                    };
                    img.onerror = function(error) {
                        reject(new Error('Failed to load stage image: ' + error));
                    };
                    img.src = dataURL;
                } catch (error) {
                    reject(error);
                }
            });
        }

        // ===================================================================
        // PDF EXPORT
        // ===================================================================
        async function exportPDF() {
            showLoading(true);
            
            try {
                // Try to get jsPDF from different possible locations
                let jsPDF;
                
                if (window.jspdf && window.jspdf.jsPDF) {
                    jsPDF = window.jspdf.jsPDF;
                } else if (typeof window.jsPDF !== 'undefined') {
                    jsPDF = window.jsPDF;
                } else if (typeof jsPDF !== 'undefined') {
                    jsPDF = window.jsPDF;
                } else {
                    throw new Error('jsPDF library not found. Please refresh the page and try again.');
                }
                
                if (!jsPDF) {
                    throw new Error('jsPDF constructor not available. Please refresh the page.');
                }
                
                const pdf = new jsPDF('landscape', 'mm', 'a4');
                
                // Title
                pdf.setFontSize(20);
                pdf.text(APP_STATE.projectName, 15, 20);
                
                // Date
                pdf.setFontSize(10);
                pdf.text(`Generated: ${new Date().toLocaleString()}`, 15, 28);
                
                // Project info
                pdf.setFontSize(12);
                let y = 40;
                pdf.text('Project Summary', 15, y);
                y += 8;
                pdf.setFontSize(10);
                pdf.text(`Access Points: ${APP_STATE.accessPoints.length}`, 20, y);
                y += 6;
                pdf.text(`Walls: ${APP_STATE.walls.length}`, 20, y);
                y += 6;
                pdf.text(`Rooms: ${APP_STATE.rooms.length}`, 20, y);
                y += 6;
                pdf.text(`Building Area: ${APP_STATE.buildingArea.toFixed(1)} sq ft`, 20, y);
                y += 6;
                pdf.text(`Scale: ${APP_STATE.scale.toFixed(4)} ft/px`, 20, y);
                y += 6;
                pdf.text(`Coverage (>-65dBm): ${document.getElementById('stat-coverage').textContent}`, 20, y);
                
                // AP List
                y += 10;
                pdf.setFontSize(12);
                pdf.text('Access Point Configuration', 15, y);
                y += 8;
                pdf.setFontSize(9);
                
                APP_STATE.accessPoints.forEach((ap, idx) => {
                    if (y > 180) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    const isRouter = ap.device.model.toLowerCase().includes('router');
                    const deviceType = isRouter ? 'Router' : 'AP';
                    
                    pdf.text(`${idx + 1}. ${ap.config.name} (${deviceType})`, 20, y);
                    y += 5;
                    pdf.text(`   Model: ${ap.device.vendor} ${ap.device.model}`, 20, y);
                    y += 5;
                    pdf.text(`   Position: (${ap.x.toFixed(1)}, ${ap.y.toFixed(1)}) Height: ${ap.config.height}ft`, 20, y);
                    y += 5;
                    pdf.text(`   Power: 2.4GHz ${ap.config.tx24}dBm, 5GHz ${ap.config.tx5}dBm`, 20, y);
                    y += 7;
                });
                
                // Add heatmap image
                if (APP_STATE.heatmapEnabled && APP_STATE.accessPoints.length > 0) {
                    try {
                        pdf.addPage();
                        pdf.setFontSize(12);
                        pdf.text('Coverage Heatmap', 15, 20);
                        
                        const canvas = await captureCanvas();
                        const imgData = canvas.toDataURL('image/png');
                        
                        const imgWidth = 250;
                        const imgHeight = (canvas.height / canvas.width) * imgWidth;
                        
                        pdf.addImage(imgData, 'PNG', 15, 30, imgWidth, Math.min(imgHeight, 150));
                    } catch (imgError) {
                        console.error('Error adding heatmap to PDF:', imgError);
                        pdf.setFontSize(10);
                        pdf.text('(Heatmap image could not be generated)', 20, 30);
                    }
                }
                
                // Save
                pdf.save(`${APP_STATE.projectName}_Report.pdf`);
                updateStatus('PDF exported successfully');
            } catch (error) {
                console.error('Error exporting PDF:', error);
                alert('Error exporting PDF: ' + error.message + '\n\nPlease refresh the page and try again.');
            } finally {
                showLoading(false);
            }
        }
        
        // ===================================================================
        // UI HELPERS
        // ===================================================================
        function selectObject(object, type) {
            APP_STATE.selectedObject = { object, type };
            updateUI();
        }
        
        function updateUI() {
            const selectionInfo = document.getElementById('selection-info');
            const apConfigSection = document.getElementById('ap-config-section');
            const wallConfigSection = document.getElementById('wall-config-section');
            
            // Hide all sections first
            apConfigSection.style.display = 'none';
            wallConfigSection.style.display = 'none';
            
            if (APP_STATE.selectedObject && APP_STATE.selectedObject.type === 'ap') {
                const ap = APP_STATE.selectedObject.object;
                
                selectionInfo.innerHTML = `
                    <p><strong>Type:</strong> Access Point</p>
                    <p><strong>Position:</strong> (${ap.x.toFixed(1)}, ${ap.y.toFixed(1)})</p>
                `;
                
                apConfigSection.style.display = 'block';
                document.getElementById('ap-name').value = ap.config.name;
                document.getElementById('ap-model').value = `${ap.device.vendor} ${ap.device.model}`;
                document.getElementById('ap-ssid').value = ap.config.ssid;
                document.getElementById('ap-height').value = ap.config.height;
                document.getElementById('ap-tx-24').value = ap.config.tx24;
                document.getElementById('ap-tx-5').value = ap.config.tx5;
                document.getElementById('ap-channel-24').value = ap.config.channel24;
                document.getElementById('ap-channel-5').value = ap.config.channel5;
                document.getElementById('ap-antenna-type').value = ap.config.antennaType;
                document.getElementById('ap-orientation').value = ap.config.orientation;
                
                document.getElementById('tx-24-value').textContent = ap.config.tx24;
                document.getElementById('tx-5-value').textContent = ap.config.tx5;
                document.getElementById('orientation-value').textContent = ap.config.orientation;
                
                const orientationGroup = document.getElementById('antenna-orientation-group');
                orientationGroup.style.display = ap.config.antennaType === 'directional' ? 'block' : 'none';
            } else if (APP_STATE.selectedObject && APP_STATE.selectedObject.type === 'wall') {
                const wall = APP_STATE.selectedObject.object;
                
                selectionInfo.innerHTML = `
                    <p><strong>Type:</strong> Wall</p>
                    <p><strong>Points:</strong> ${wall.points.length / 2}</p>
                    <p><strong>Attenuation:</strong> ${wall.attenuation} dB</p>
                `;
                
                wallConfigSection.style.display = 'block';
                document.getElementById('wall-material').value = wall.attenuation;
            } else {
                selectionInfo.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">No object selected</p>';
            }
            
            feather.replace();
        }
        
        function updateStats() {
            document.getElementById('stat-aps').textContent = APP_STATE.accessPoints.length;
            document.getElementById('stat-walls').textContent = APP_STATE.walls.length;
            document.getElementById('stat-clients').textContent = APP_STATE.clients.length;
            document.getElementById('stat-rooms').textContent = APP_STATE.rooms.length;
            document.getElementById('stat-building-area').textContent = APP_STATE.buildingArea.toFixed(1) + ' sq ft';
        }
        
        function updateStatus(message) {
            document.getElementById('status-left').textContent = message;
        }
        
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.add('active');
            } else {
                loading.classList.remove('active');
            }
        }
        
        function deleteSelectedObject() {
            if (!APP_STATE.selectedObject) return;
            
            if (APP_STATE.selectedObject.type === 'ap') {
                deleteAP();
            }
        }
        
        // ===================================================================
        // UNDO SYSTEM
        // ===================================================================
        function saveUndoState(action, data) {
            APP_STATE.undoStack.push({ action, data, timestamp: Date.now() });
            if (APP_STATE.undoStack.length > 50) {
                APP_STATE.undoStack.shift(); // Keep last 50 actions
            }
        }
        
        function undoLastAction() {
            if (APP_STATE.undoStack.length === 0) {
                updateStatus('Nothing to undo');
                return;
            }
            
            const lastAction = APP_STATE.undoStack.pop();
            
            switch(lastAction.action) {
                case 'addAP':
                    const apIndex = APP_STATE.accessPoints.findIndex(ap => ap.id === lastAction.data.id);
                    if (apIndex > -1) {
                        APP_STATE.accessPoints.splice(apIndex, 1);
                        const group = layer.findOne('#' + lastAction.data.id);
                        if (group) group.destroy();
                        updateStatus('Undo: AP removed');
                    }
                    break;
                    
                case 'addWall':
                    const wallIndex = APP_STATE.walls.findIndex(w => w.id === lastAction.data.id);
                    if (wallIndex > -1) {
                        APP_STATE.walls.splice(wallIndex, 1);
                        const line = layer.findOne('#' + lastAction.data.id);
                        if (line) line.destroy();
                        updateStatus('Undo: Wall removed');
                    }
                    break;
                    
                case 'addObstacle':
                    const obsIndex = APP_STATE.obstacles.findIndex(o => o.id === lastAction.data.id);
                    if (obsIndex > -1) {
                        APP_STATE.obstacles.splice(obsIndex, 1);
                        const rect = layer.findOne('#' + lastAction.data.id);
                        if (rect) rect.destroy();
                        updateStatus('Undo: Obstacle removed');
                    }
                    break;
            }
            
            layer.batchDraw();
            updateHeatmap();
            updateStats();
        }

        // ===================================================================
        // SAMPLE PROJECT (for testing)
        // ===================================================================
        function loadSampleProject() {
            updateStatus('Ready - Upload a floor plan or add access points to begin');
            // Show help on first load
            setTimeout(() => {
                document.getElementById('help-box').style.display = 'block';
            }, 500);
        }
    </script>
</body>
</html>
